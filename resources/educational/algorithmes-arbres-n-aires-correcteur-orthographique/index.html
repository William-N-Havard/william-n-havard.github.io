<!DOCTYPE html>
<html>

  <head>
	<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>William N. Havard
	| Arbres n-aires : Correcteur Orthographique</title>
<meta name="description" content="William N. Havard's website!">

<!-- Open Graph --><!-- Bootstrap & MDB -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css" integrity="sha512-RO38pBRxYH3SoOprtPTD86JFOclM51/XTIdEPh5j8sj4tp8jmQIx26twG52UaLi//hQldfrh7e51WzP9wuP32Q==" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css" integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

<!-- Code Syntax Highlighting -->
<link rel="stylesheet" href="/assets/css/github.css" />

<!-- Styles -->
<!--<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>W</text></svg>">-->
<link rel="icon" id="favicon" href="/assets/img/favicon/android-chrome-512x512_latin.png"/>
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="canonical" href="/resources/educational/algorithmes-arbres-n-aires-correcteur-orthographique/">

<!-- JQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>


<!-- Theming-->


<script>
	let favicon_list = ["/assets/img/favicon/android-chrome-512x512_amharic.png","/assets/img/favicon/android-chrome-512x512_arabic_waw.png","/assets/img/favicon/android-chrome-512x512_armenian.png","/assets/img/favicon/android-chrome-512x512_brahmi.png","/assets/img/favicon/android-chrome-512x512_chinese.png","/assets/img/favicon/android-chrome-512x512_coptic.png","/assets/img/favicon/android-chrome-512x512_cyrillic.png","/assets/img/favicon/android-chrome-512x512_egyptian-hieroglyphs.png","/assets/img/favicon/android-chrome-512x512_georgian.png","/assets/img/favicon/android-chrome-512x512_greek_digamma.png","/assets/img/favicon/android-chrome-512x512_gujarati.png","/assets/img/favicon/android-chrome-512x512_hangul.png","/assets/img/favicon/android-chrome-512x512_hebrew.png","/assets/img/favicon/android-chrome-512x512_hiragana.png","/assets/img/favicon/android-chrome-512x512_katakana.png","/assets/img/favicon/android-chrome-512x512_kharosthi.png","/assets/img/favicon/android-chrome-512x512_latin.png","/assets/img/favicon/android-chrome-512x512_latin_vend.png","/assets/img/favicon/android-chrome-512x512_malayalam.png","/assets/img/favicon/android-chrome-512x512_marathi.png","/assets/img/favicon/android-chrome-512x512_mongolian.png","/assets/img/favicon/android-chrome-512x512_nko.png","/assets/img/favicon/android-chrome-512x512_old-english_wynn.png","/assets/img/favicon/android-chrome-512x512_phoenician.png","/assets/img/favicon/android-chrome-512x512_runic_wunjo.png","/assets/img/favicon/android-chrome-512x512_syriac.png","/assets/img/favicon/android-chrome-512x512_tamil.png","/assets/img/favicon/android-chrome-512x512_thai.png","/assets/img/favicon/android-chrome-512x512_ugaritic.png","/assets/img/favicon/android-chrome-512x512_yiddish.png",]
	let faviconElem = document.getElementById('favicon');
	//let splitFilename = faviconElem.getAttribute('href').split('/');

	faviconElem.setAttribute('href', favicon_list[Math.floor(favicon_list.length*Math.random())]);
	//faviconElem.setAttribute('href', splitFilename.slice(0, splitFilename.length - 1).join('/') + '/' + splitFilename[splitFilename.length - 1].replace(/(.*?)(\d+)(.png)/, "$1"+Math.floor(25*Math.random())+"$3"));
</script>


<!-- MathJax -->
<script type="text/javascript">
	window.MathJax = {
	tex: {
	  tags: 'ams'
	}
	};
</script>
<script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script></head>

  <body class="fixed-top-nav ">

    <!-- Header -->

    <header>

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
	    
        
			<a class="navbar-brand title font-weight-lighter" href="https://william-n-havard.github.io/">
				<span class="font-weight-bold">William</span> N.  Havard
			</a>
        
        <!-- Navbar Toggle -->
        <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
			<span class="sr-only">Toggle navigation</span>
			<span class="icon-bar top-bar"></span>
			<span class="icon-bar middle-bar"></span>
			<span class="icon-bar bottom-bar"></span>
        </button>
        <div class="collapse navbar-collapse text-right" id="navbarNav">
			<ul class="navbar-nav ml-auto flex-nowrap">
			<!-- About -->
			<li class="nav-item ">
				<a class="nav-link" href="/">
					About
					
				</a>
			</li>
			
			<!-- Other pages -->
			
			
				
			
				
			
				
			
				
			
				
			
				
			
				
			
				
					
							<li class="nav-item ">
								<a class="nav-link" href="/publications/">
									Publications
									
								</a>
						</li>
					
				
			
				
					
							<li class="nav-item ">
								<a class="nav-link" href="/resources/">
									Resources
									
								</a>
						</li>
					
				
			
				
			
            
          </ul>
        </div>
		
			<div class="progress-container">
				<div class="progress-bar" id="reading-progress-bar"></div>
			</div>  
		
    </div>
  </nav>
</header>


    <!-- Content -->

    <div class="container mt-5">
	  <a id="top-anchor" class="invisible"></a>
      

	<div id="breadcrumb">
		<a href="/"><i class="fas fa-home"></i></a>
		  &gt; <a href="/resources/">Resources</a>
		  
		
		  &gt; <a href="/resources/educational/">Educational</a>
		  
		
		  
			&gt; Arbres n-aires : Correcteur Orthographique
		  
		
	</div>

<div class="post">

	<header class="post-header ">
		<h1 class="post-title">Arbres n-aires : Correcteur Orthographique</h1> 
		<div class="post-description">
			<p>Application des arbres n-aires à la création d'un correcteur orthographique simple en Python</p>
			<div class="container d-inline-block mx-0 mb-1 pl-0 pr-0">
				<span class="float-left">
				
					<i class="far fa-calendar-alt"></i> Posted: October 10, 2021
					
				
				</span>
				
	
	
		<span class="float-right"><i class="far fa-clock"></i> 51 min.</span>
	

			</div>
		</div>
	</header>
	
	<article>
		<ol id="toc" class="section-nav">
<li class="toc-entry toc-h1"><a href="#principe">Principe</a></li>
<li class="toc-entry toc-h1">
<a href="#approches">Approches</a>
<ol>
<li class="toc-entry toc-h2"><a href="#distance-d%C3%A9dition">Distance d’édition</a></li>
<li class="toc-entry toc-h2"><a href="#enum%C3%A9ration-des-%C3%A9ditions-possibles">Enumération des éditions possibles</a></li>
<li class="toc-entry toc-h2">
<a href="#arbre-n-aire">Arbre n-aire</a>
<ol>
<li class="toc-entry toc-h3"><a href="#d%C3%A9placement-dans-larbre--sans-%C3%A9ditions">Déplacement dans l’arbre : sans éditions</a></li>
<li class="toc-entry toc-h3"><a href="#d%C3%A9placement-dans-larbre--%C3%A9ditions">Déplacement dans l’arbre : éditions</a></li>
<li class="toc-entry toc-h3"><a href="#conclusion-sur-lutilisation-dun-arbre-n-aire">Conclusion sur l’utilisation d’un arbre n-aire</a></li>
</ol>
</li>
</ol>
</li>
<li class="toc-entry toc-h1">
<a href="#code">Code</a>
<ol>
<li class="toc-entry toc-h2"><a href="#la-m%C3%A9thode-find_closest">La méthode find_closest</a></li>
<li class="toc-entry toc-h2">
<a href="#la-m%C3%A9thode-_find_closest">La méthode _find_closest</a>
<ol>
<li class="toc-entry toc-h3"><a href="#les-set">Les set</a></li>
<li class="toc-entry toc-h3"><a href="#avancer-dans-larbre--sans-%C3%A9ditions">Avancer dans l’arbre : sans éditions</a></li>
<li class="toc-entry toc-h3">
<a href="#avancer-dans-larbre--avec-%C3%A9ditions">Avancer dans l’arbre : avec éditions</a>
<ol>
<li class="toc-entry toc-h4"><a href="#d%C3%A9l%C3%A9tions-et-subsitutions">Délétions et Subsitutions</a></li>
<li class="toc-entry toc-h4"><a href="#insertions-et-transpositions">Insertions et Transpositions</a></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li class="toc-entry toc-h1"><a href="#pour-aller-plus-loin">Pour aller plus loin</a></li>
<li class="toc-entry toc-h1"><a href="#conclusion">Conclusion</a></li>
</ol>
<p>Les correcteurs orthographiques sont de petits programmes qui permettent de détecter les mots mal orthographiés et permettent de suggérer à l’utilisateur des propositions de correction. Comme les <a href="/resources/educational/algorithmes-arbres-n-aires-autocompletion/" target="_blank">programmes d’auto-complétion</a>, ils sont intégrés dans de nombreux programmes (traitement de texte, IDE, etc.). Nous allons ici réaliser un correcteur orthographique simple en utilisant un arbre <em>n</em>-aire. Etant donné que nous avons déjà réalisé un programme utilisant un arbre <em>n</em>-aire (voir <em>supra</em>), je ne redétaillerai pas la terminologie utilisée ni les parties du programme déjà détaillées dans l’article précédent.</p>

<h1 id="principe">
<a class="anchor" href="#principe" aria-hidden="true"><span class="octicon octicon-link"></span></a>Principe</h1>

<p>L’idée d’un correcteur orthographique est ① d’identifier les mots mal orthographiés et ② de rechercher les mots qui ont la distance d’édition la plus proche possible des mots mal orthographiés. La distance d’édition est une mesure qui indique le nombre d’opérations de substitution (1 pour « abocat » → « avocat »), de délétion (1 pour « avvocat » → « avocat ») et d’insertion (« aocat » → « avocat ») réunies qu’il faut pour transformer le mot fautif en un mot correct. On peut également rajouter une autre opération, la transposition (« aovcat » → « avocat ») qui remplace le couple d’opérations insertion + substitution :  « aovcat » → « avovcat » (insertion de « v ») → « avocat » (délétion de « v »).</p>

<p>Identifier des mots mal orthographiés est facile, il suffit de regarder si les mots existent où non dans la structure de données que nous utilisons. L’étape la plus compliquée est de rechercher des mots qui ont la distance d’édition la plus proche possible.</p>

<h1 id="approches">
<a class="anchor" href="#approches" aria-hidden="true"><span class="octicon octicon-link"></span></a>Approches</h1>

<h2 id="distance-dédition">
<a class="anchor" href="#distance-d%C3%A9dition" aria-hidden="true"><span class="octicon octicon-link"></span></a>Distance d’édition</h2>

<p>La première solution consiste à calculer la distance d’édition entre le mot mal orthographié et chacun des mots de la structure de données, et ne conserver que les mots pour lesquels la distance est en dessous d’un seuil défini par l’utilisateur. Cependant, cette solution est <strong>extrêmement coûteuse</strong> puisqu’elle implique de calculer une distance d’édition pour <strong>chacun</strong> des mots de la structure de données. De plus, calculer une distance d’édition — en utilisant par exemple la distance de Levenshtein — est également une opération qui peut être relativement coûteuse. Ainsi, cette approche est peu efficace.</p>

<h2 id="enumération-des-éditions-possibles">
<a class="anchor" href="#enum%C3%A9ration-des-%C3%A9ditions-possibles" aria-hidden="true"><span class="octicon octicon-link"></span></a>Enumération des éditions possibles</h2>

<p>Dans cette approche, on génère l’ensemble des éditions possibles à partir du mot mal orthographié et on filtre la liste générée pour ne garder que les mots qui existent. C’est l’option adoptée par Peter Norvig dans son <a href="https://norvig.com/spell-correct.html" target="_blank">implémentation</a>. Imaginons que le mot mal orthographié est « aovcat », nous allons partir de celui-ci et générer l’ensemble de insertions, délétions, substitutions et transpositions possibles :</p>

<ul>
  <li>Pour les <strong>insertions</strong> nous avons <code class="language-plaintext highlighter-rouge">['aaovcat', 'baovcat', ..., 'uavocat', ..., 'aovcatz']</code>
</li>
  <li>Pour les <strong>délétions</strong> nous avons <code class="language-plaintext highlighter-rouge">['ovcat', 'avcat', 'aocat', ..., 'aovca']</code>
</li>
  <li>Pour les <strong>substitutions</strong> nous avons <code class="language-plaintext highlighter-rouge">['aovcat', 'bovcat', 'covcat', ..., 'aovcaz']</code>
</li>
  <li>Pour les <strong>transpositions</strong> nous avons <code class="language-plaintext highlighter-rouge">['oavcat', 'avocat', 'aocvat ', ..., 'aovcta']</code>
</li>
</ul>

<p><br>
L’intuition de cette approche est que l’on espère que l’une des opérations d’insertion, délétion, substitution et transposition génèrera le mot correct. C’est d’ailleurs le cas si le mot erroné a une distance d’édition de <strong>1</strong> avec le mot correct. Il suffit simplement de filtrer la liste pour ne garder que les mots qui existent (ainsi on supprime « aaovcat », « oavcat », etc.) et l’on conserve pour finir seulement le mot correct « avocat » (ici, généré par l’opération de transposition). Si l’on souhaitait pouvoir récupérer la correction d’un mot qui contiendrait <strong>2</strong> erreurs, il faudrait générer l’ensemble des éditions possibles (insertions, délétions, substitutions et transpositions) de l’ensemble des mots que l’on aurait déjà générés via cette même opération.</p>

<p>La solution proposée par Norvig repose sur l’utilisation d’un alphabet pour savoir quels caractères insérer ou substituer (<code class="language-plaintext highlighter-rouge">letters    = 'abcdefghijklmnopqrstuvwxyz'</code>). Cela n’est pas idéal, car l’alphabet ne fonctionne que pour la langue pour laquelle le programme a été conçu. Ainsi, si l’on souhaitait travailler sur du français, il serait nécessaire d’ajouter de nouveaux caractères (« é », « è », « ù », etc.). On pourrait aisément résoudre ce problème en ne considérant que les caractères contenus dans le dictionnaire d’entrée.</p>

<p>Cependant, cette approche par liste de caractères se révèle problématique à un autre niveau. Plus il y a de caractères à considérer, plus il y a de d’insertions et de substitutions possibles. Si l’on considère un alphabet de 26 lettres, pour chaque mot mal orthographié de <em>n</em> caractères, le programme génèrera :</p>

<ul>
  <li>
<em>n+1</em> * 26 <strong>insertions</strong>
</li>
  <li>
<em>n</em> <strong>délétions</strong>
</li>
  <li>n * 26 <strong>substitutions</strong>
</li>
  <li>
<em>n-1</em> <strong>transpositions</strong>
</li>
  <li>Total : <strong>53n + 25 possibilités</strong>
</li>
</ul>

<p><br>en supposant que l’alphabet que l’on considère pour l’insertion et la substitution de caractère est composé de 26 lettres (et ce, juste pour trouver l’orthographe correcte de mots qui n’ont une distance d’édition de <strong>1</strong> avec le mot correct !). Ainsi, on constate ici un double effet : plus le mot sera long et plus l’on considérera de lettres dans l’alphabet, plus il y aura de propositions à filtrer. Imaginez si l’on prend en plus en compte les lettres majuscules !</p>

<p>Cette solution n’est pas optimale pour une autre raison également. Par exemple, on sait que des mots qui commencent par « ua » (comme dans l’option générée par l’opération d’insertion) sont des mots plutôt rares (voire inexistants) en français. On aimerait donc pouvoir générer seulement des éditions qui soient possibles en français, ce qui nous permettra d’éliminer d’office beaucoup de noms impossibles. De la même manière, l’approche par alphabet nous oblige à considérer des lettres qui sont extrêmement rares en français pour des substitutions ou insertions que l’on sait peu probables. Par exemple en français, nous sommes obligés de considérer la lettre « ÿ » (qui apparaît dans quelques noms de villes comme <a href="https://fr.wikipedia.org/wiki/Ay_(Marne)" target="_blank">Aÿ</a> ou <a href="https://fr.wikipedia.org/wiki/L'Ha%C3%BF-les-Roses" target="_blank">L’Haÿ-les-Roses</a>) et qui sera utilisée pour chacune des insertions et substitutions, quel que soit le mot.</p>

<h2 id="arbre-n-aire">
<a class="anchor" href="#arbre-n-aire" aria-hidden="true"><span class="octicon octicon-link"></span></a>Arbre <em>n</em>-aire</h2>

<p>Je vais vous proposer ici d’implémenter un correcteur orthographique qui fonctionne avec un arbre <em>n</em>-aire. Conceptuellement, l’approche est proche de celle de Norvig (cf. <em>supra</em>). Cependant, ici nous allons tâcher de filtrer les propositions de correction le plus tôt possible et nous n’allons considérer que les lettres qui sont possibles à moment <em>t</em> — qui dépend de l’endroit où nous sommes dans le mot — pour les insertions et substitutions.</p>

<p>Pour illustrer ce dernier point, imaginons que l’utilisateur ait mal orthographié le mot « coquelicot » en écrivant « coqueliot ». Pour corriger ce mot, il suffit de rajouter le « c » entre le « i » et le « o » . Imaginons que nous ayons lu les <em>c</em> premiers caractères du mot et sommes arrivés au caractère « i ». Si l’on faisait une implémentation <em>à la</em> Norvig, on testerait ici plusieurs possibilités d’insertion « a » pour « coqueli<strong>a</strong>ot », puis « b », puis « c » le tout jusqu’à « z » pour « coqueli<strong>z</strong>ot ». Or, en français (en tous cas, d’après la liste de mot de Lexique v3.83), la seule lettre possible après le « i » ici est le « c ». Inutile donc de considérer toutes les autres lettres à l’exception du « c » pour corriger le mot. C’est donc ce que nous allons faire !</p>

<h3 id="déplacement-dans-larbre--sans-éditions">
<a class="anchor" href="#d%C3%A9placement-dans-larbre--sans-%C3%A9ditions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Déplacement dans l’arbre : sans éditions</h3>

<p>Pour bien comprendre intuitivement ce que nous allons implémenter, il convient de bien comprendre comment l’on peut se déplacer de nœud en nœud dans l’arbre. C’est ce qu’illustre la figure suivante :</p>

<figure class="text-center">
  <img src="/assets/educational/Algorithmes_Arbres_n-aires_Correcteur-Orthographique/arbre_n-aire_deplacement.png" alt="Déplacement dans un arbre n-aire." class="img-fluid" style="max-width: px">
  <figcaption class="font-italic text-center">Déplacement dans un arbre n-aire.</figcaption>
</figure>

<p>Les flèches en gras noires figurent le chemin emprunté. Le mot en gras est l’état de la chaîne avant le déplacement d’un nœud à l’autre et les lettres entre crochets indiquent le caractère qui permet de passer d’un nœud à l’autre. Ainsi, pour se déplacer de nœud en nœud, on regarde le premier caractère de la chaîne, si celui-ci correspond à l’étiquette d’un des nœuds fils du nœud sur lequel on est, on peut se déplacer sur celui-ci, puis l’on examine le caractère suivant, etc. Si après avoir consommé tous les caractères on est arrivé sur un nœud marquant la fin d’un mot <code class="language-plaintext highlighter-rouge">∅</code>, c’est que le mot initial était bien un mot existant. Si cette opération de déplacement est floue, n’hésitez pas à lire <a href="/resources/educational/algorithmes-arbres-n-aires-autocompletion/" target="_blank">cet article</a> avant où j’aborde l’opération plus en détail.</p>

<h3 id="déplacement-dans-larbre--éditions">
<a class="anchor" href="#d%C3%A9placement-dans-larbre--%C3%A9ditions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Déplacement dans l’arbre : éditions</h3>

<p>Maintenant que nous avons compris comment nous déplacer dans l’arbre lorsque le mot rentré existe effectivement dans l’arbre, nous allons voir comment utiliser l’arbre pour générer des éditions lorsque le mot rentré est mal orthographié, ce qui nous permettra finalement de trouver sa correction. Ici, nous n’allons autoriser qu’une seule édition — quelle qu’elle soit : insertion, délétion, substitution ou transposition.</p>

<ul>
  <li><a id="figure-deletion-substitution"><strong>Délétion et Substitution</strong></a></li>
</ul>

<p>Voyons comment nous pouvons corriger le mot « avoat » en « avocat » (où l’utilisateur a oublié la lettre « c » donc) :</p>

<figure class="text-center">
  <img src="/assets/educational/Algorithmes_Arbres_n-aires_Correcteur-Orthographique/arbre_n-aire_avoat-avocat.png" alt="Déplacement dans un arbre n-aire en appliquant une édition (valable pour corriger une délétion ou substitution)." class="img-fluid" style="max-width: px">
  <figcaption class="font-italic text-center">Déplacement dans un arbre n-aire en appliquant une édition (valable pour corriger une délétion ou substitution).</figcaption>
</figure>

<p>Comme dans la précédente figure, les flèches en gras noires figurent le chemin « normal », le mot en gras est l’état de la chaîne avant le déplacement d’un nœud à l’autre et les lettres entre crochets indiquent le caractère qui permet de passer d’un nœud à l’autre.</p>

<p>Au début, il n’y a aucun problème et on peut aller de nœud en nœud dans l’arbre jusqu’au nœud « o ». Arrivés sur ce nœud, la chaîne qu’il nous reste à parcourir est « at » ; cependant, à partir du nœud « o » il n’y a aucun nœud « a » sur lequel nous pourrions aller. Ainsi, pour passer au nœud suivant, nous allons nous autoriser à faire une insertion (pour corriger la délétion accidentelle de l’utilisateur). Pour ce faire, nous allons nous autoriser à aller sur <strong>tous les nœuds fils</strong> du nœud « o », c’est à dire ici « i » et « c ». Cependant, nous ne pouvons pas aller par la voie normale (flèches noires marquées d’un ❌) sinon il aurait fallu que le reste de la chaîne commence soit par « i » soit par « c ». Au lieu de cela, nous passons par les voies rouges, ce qui reviendra par la suite à rajouter la lettre manquante. Nous indiquons à partir de là, sous la chaîne de caractères, le nombre d’éditions que nous avons apportées (ici 1).</p>

<p>A partir de là, nous arrivons sans problème à parcourir le reste de la chaîne « at » pour la branche du dessous (✔️) et arrivons sur la fin de mot <code class="language-plaintext highlighter-rouge">∅</code> . Pour la branche du dessus, nous voyons que nous sommes bloqués : dans le cas de la flèche noire avec ❌ parce que la chaîne « at » qu’il reste à consommer commence par « a » et le seul nœud accessible depuis le nœud « i » est le nœud « n » ; et dans le cas de la flèche rouge avec ❌parce que nous ne pouvons plus faire d’édition (je vous rappelle que nous avons défini que le nombre maximal d’éditions serait de 1). Il est à noter que si l’utilisateur avait substitué une lettre par une autre (par exemple « avacat »), nous aurions effectué la même opération.</p>

<p>Une fois arrivés à la fin d’un mot, comme dans le cas de la branche du dessous, nous allons maintenant remonter vers la racine de l’arbre (chemin indiqué en bleu). Cette opération est facile (et se fait de la même manière que pour l’auto-complétion) et nous permet de reconstruire le mot corrigé. Ainsi, arrivés sur le nœud « c » lors du retour, nous remontons vers le nœud « o », et c’est lors de cette étape que nous « rajoutons » la lettre « c » qui était manquante de l’entrée de l’utilisateur.</p>

<ul>
  <li><a id="insertion-transposition"><strong>Insertion et Transposition</strong></a></li>
</ul>

<p>Dans le cas d’une insertion ou d’une transposition, l’arbre est relativement similaire. Cependant, là où dans le cas de la délétion ou de la substitution nous nous autorisions à passer à l’ensemble des nœuds fils d’un nœud donné sans toucher à la chaîne de caractères, dans le cas d’une insertion ou d’une transposition nous allons nous autoriser à modifier la chaîne de caractères. Dans la figure ci-dessous, nous voyons le cas où l’utilisateur aurait inséré une lettre en trop : ici « d » dans « avodcat ».</p>

<figure class="text-center">
  <img src="/assets/educational/Algorithmes_Arbres_n-aires_Correcteur-Orthographique/arbre_n-aire_avodcat-avocat.png" alt="Déplacement dans un arbre n-aire en appliquant une édition (valable pour corriger une insertion ou transposition)." class="img-fluid" style="max-width: px">
  <figcaption class="font-italic text-center">Déplacement dans un arbre n-aire en appliquant une édition (valable pour corriger une insertion ou transposition).</figcaption>
</figure>

<p>Comme pour l’exemple précédent, nous arrivons sur le nœud « o » sans problème. La chaîne qu’il reste est « dcat », mais il n’y a cependant pas de nœud « d » lié au nœud « o ». Nous nous autorisons ici à éditer la chaîne en retirant la lettre « d ». Une fois cette chaîne modifiée, la nouvelle lettre du début devient « c », ce qui nous autorise à aller sur le nœud suivant et finalement atteindre la fin du mot. Si la première lettre n’avait pas permis d’aller sur un autre nœud, nous nous serions dans ce cas arrêtés, ne pouvant plus faire d’autres éditions (car nous avons défini le nombre d’éditions maximum à 1).</p>

<p>Dans le cas d’une transposition, par exemple « avcoat », une fois arrivés sur le nœud « c » nous aurions regardé s’il ce nœud avait pour fils la deuxième lettre de la chaîne restant à traiter (« c<strong>[o]</strong>at »), et si tel avait été le cas, nous aurions inversé les deux premières lettres (« <strong>co</strong>at » → « <strong>oc</strong>at ») pour nous permettre d’aller plus loin.</p>

<h3 id="conclusion-sur-lutilisation-dun-arbre-n-aire">
<a class="anchor" href="#conclusion-sur-lutilisation-dun-arbre-n-aire" aria-hidden="true"><span class="octicon octicon-link"></span></a>Conclusion sur l’utilisation d’un arbre <em>n</em>-aire</h3>

<p>Nous voyons ainsi que l’utilisation d’un arbre <em>n</em>-aire nous permet de faire des éditions au moment ou celles-ci sont possibles (notamment dans le cas de l’insertion et de la substitution).</p>

<p>Il y a un point que je n’ai pas abordé dans les points précédents : ceux-ci peuvent laisser croire que nous appliquons un seul type d’édition (soit insertion, soit substitution, soit délétion, soit transposition) à un moment donné. Or, en réalité, à chaque étape nous appliquons <strong>tous</strong> les types d’édition possibles. En effet, lorsqu’un mot est erroné, nous ne savons <em>a priori</em> pas où l’erreur a été faite, ni quel est le type d’erreur qui a été fait. Par exemple, si l’utilisateur écrit « Je mange une <strong>poime</strong> », « poime » peut être corrigé soit en « poi<strong>r</strong>e » soit en « po<strong>m</strong>me », les deux étant possibles, les erreurs n’étant simplement pas au même endroit.</p>

<p>Ainsi, comme pour Norvig, nous faisons toutes les éditions possibles. Cependant, la plupart ne permettront pas d’aller explorer l’arbre très loin et seront donc vite éliminées. Nous pouvons noter que nous générons tout de même moins d’éditions que Norvig, car nous n’explorons que les éditions <strong>possibles</strong> pour un nœud donné.</p>

<h1 id="code">
<a class="anchor" href="#code" aria-hidden="true"><span class="octicon octicon-link"></span></a>Code</h1>

<p>Maintenant que nous avons vu comment nous allions appliquer les corrections en utilisant un arbre <em>n</em>-aire, il est venu le moment de le coder ! Le code complet contient trois fichiers <code class="language-plaintext highlighter-rouge">interface.py</code>, <code class="language-plaintext highlighter-rouge">trie.py</code> et <code class="language-plaintext highlighter-rouge">main.py</code>. Nous n’allons détailler que le code de <code class="language-plaintext highlighter-rouge">trie.py</code> celui-ci étant au cœur de l’application. Quant à <code class="language-plaintext highlighter-rouge">interface.py</code> et <code class="language-plaintext highlighter-rouge">main.py</code>, tous deux sont en très grande partie identiques à ceux de <a href="/resources/educational/algorithmes-arbres-n-aires-autocompletion/" target="_blank">programmes d’auto-complétion</a>.</p>

<p>C’est également le cas pour le code de <code class="language-plaintext highlighter-rouge">trie.py</code>. Pour rappel, voici le code de base de ce fichier :</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td>
<td class="code"><pre><span class="k">class</span> <span class="nc">Trie</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="sh">''</span><span class="p">,</span> <span class="n">words</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        Initialisation de l</span><span class="sh">'</span><span class="s">objet (rappel en Python, le constructeur est __new__)
        :param end: signe de fin de mot à utiliser
        :param words: liste des mots à ajouter au
        </span><span class="sh">"""</span>
        <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">self</span><span class="p">.</span><span class="n">end</span>  <span class="o">=</span> <span class="n">end</span>
    
        <span class="k">if</span> <span class="n">words</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">add_words</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">add_word</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        Permet d</span><span class="sh">'</span><span class="s">ajouter UN mot au Trie
        :param word: chaine de caractères
        :return: void
        </span><span class="sh">"""</span>
        <span class="n">trie</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span>
        <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="n">trie</span> <span class="o">=</span> <span class="n">trie</span><span class="p">.</span><span class="nf">setdefault</span><span class="p">(</span><span class="n">letter</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">trie</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="k">def</span> <span class="nf">add_words</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">words</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        Permet d</span><span class="sh">'</span><span class="s">ajouter DES mots au Trie
        :param words: liste de chaines de caractères
        :return: void
        </span><span class="sh">"""</span>
        <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">add_word</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>La classe Trie a donc deux attributs <code class="language-plaintext highlighter-rouge">root</code> qui représente le nœud racine de l’arbre, et <code class="language-plaintext highlighter-rouge">end</code> qui contient le caractère qui sera utilisé pour signaler une fin de mot. Ici, j’ai opté pour une chaine vide. Nous avons également deux méthodes : <code class="language-plaintext highlighter-rouge">add_words</code> qui prend en paramètre une liste de mot et qui fait appel à la méthode <code class="language-plaintext highlighter-rouge">add_word</code> qui elle prend en paramètre une chaîne de caractères (un mot) qui sera ajouté à l’arbre. Je passe rapidement sur ces points qui sont détaillés ici](/resources/educational/algorithmes-arbres-n-aires-autocompletion/){:target=”_blank”}.</p>

<h2 id="la-méthode-find_closest">
<a class="anchor" href="#la-m%C3%A9thode-find_closest" aria-hidden="true"><span class="octicon octicon-link"></span></a>La méthode <em>find_closest</em>
</h2>

<p>Nous allons créer la méthode <em>find_closest</em> qui aura deux arguments, dont un optionnel : un argument <code class="language-plaintext highlighter-rouge">word</code> qui sera le mot rentré par l’utilisateur, et un argument <code class="language-plaintext highlighter-rouge">edit_dist</code> qui spécifiera le nombre maximal d’éditions que l’on pourra apporter pour corriger un mot. Par défaut, ce nombre sera fixé à 3. Cette fonction renverra la liste des mots qui sont des corrections potentielles du mot passé en entrée. Il est à noter que nous ne prenons pas ici le temps de vérifier si le mot rentré par l’utilisateur est erroné (alors que l’on ferait dans un cas réel). Vous pouvez cependant prendre le temps de le faire si vous le souhaitez (en rajoutant par exemple une méthode <code class="language-plaintext highlighter-rouge">__contains__</code> qui sera chargée de vérifier si le mot existe).</p>

<p>En réalité, la méthode <code class="language-plaintext highlighter-rouge">find_closest</code> va être relativement dépouillée, car elle va faire appel à une fonction imbriquée, c’est-à-dire qu’elle fera appel à une fonction définie à l’intérieur d’elle-même :</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td>
<td class="code"><pre><span class="k">def</span> <span class="nf">find_closest</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">edit_dist</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="sh">"""</span><span class="s">
Retrouve la liste des mots les plus proches du mot `word` (en termes de distance d</span><span class="sh">'</span><span class="s">édition) dans le trie
:param edit_dist: nombre d</span><span class="sh">'</span><span class="s">éditions maximum
:param word: mot à corriger
:return: set de mots éloignés d</span><span class="sh">'</span><span class="s">au plus `edit_dist` éditions du mot `word`
</span><span class="sh">"""</span>

    <span class="k">def</span> <span class="nf">_find_closest</span><span class="p">(</span><span class="n">trie</span><span class="p">,</span> <span class="n">edit_dist</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="n">corrections</span> <span class="o">=</span> <span class="nf">set</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">corrections</span>
    
    <span class="k">return</span> <span class="nf">_find_closest</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">,</span> <span class="n">edit_dist</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>Nous voyons donc une méthode <code class="language-plaintext highlighter-rouge">find_closest</code> qui a bien deux arguments comme prévu. Cependant, on voit dans le corps de celle-ci la déclaration d’une autre fonction <code class="language-plaintext highlighter-rouge">_find_closest</code>. Pourquoi procéder ainsi ? On voit que cette dernière prend un argument de plus que <code class="language-plaintext highlighter-rouge">find_closest</code>, en l’occurrence l’argument <code class="language-plaintext highlighter-rouge">trie</code>. On voit que la fonction principale, elle, se contente de retourner ce que <code class="language-plaintext highlighter-rouge">_find_closest</code> retournera en faisant un <code class="language-plaintext highlighter-rouge">return _find_closest(self.root, edit_dist, word)</code> à la ligne 14.</p>

<p>J’ai procédé ainsi, car cela permet d’avoir une interface plus simple pour l’utilisateur. En effet, si nous n’avions pas fait cela, c’est directement <code class="language-plaintext highlighter-rouge">find_closest</code> qui aurait eu besoin d’avoir le paramètre <code class="language-plaintext highlighter-rouge">trie</code>. Ainsi, l’appel pour l’utilisateur n’aurait pas été très simple à faire et il aurait eu à écrire une ligne de ce type dans le <code class="language-plaintext highlighter-rouge">main.py</code> : <code class="language-plaintext highlighter-rouge">trie.find_closest(trie.root, "mot_a_corriger")</code>. Cela viole le principe d’encapsulation, l’utilisateur n’ayant pas à savoir le fonctionnement interne d’un objet <code class="language-plaintext highlighter-rouge">Trie</code>. En procédant comme je le propose, l’utilisateur n’a plus qu’à écrire <code class="language-plaintext highlighter-rouge">trie.find_closest("mot_a_corriger")</code> et n’a pas à se soucier de comment se nomme la racine (ce qui ne l’intéresse de toute façon pas, tout cela relevant des rouages internes de l’application).</p>

<h2 id="la-méthode-_find_closest">
<a class="anchor" href="#la-m%C3%A9thode-_find_closest" aria-hidden="true"><span class="octicon octicon-link"></span></a>La méthode <em>_find_closest</em>
</h2>

<p>Ainsi, le cœur de <code class="language-plaintext highlighter-rouge">find_closest</code> est <code class="language-plaintext highlighter-rouge">_find_closest</code> que nous allons maintenant détailler.</p>

<h3 id="les-set">
<a class="anchor" href="#les-set" aria-hidden="true"><span class="octicon octicon-link"></span></a>Les <code class="language-plaintext highlighter-rouge">set</code>
</h3>

<p>On voit dans le code précédent (ligne 10) que l’on déclare un <code class="language-plaintext highlighter-rouge">set</code> nommé <code class="language-plaintext highlighter-rouge">corrections</code> qui, comme son nom l’indique, servira à stocker les corrections possibles du mot passé en paramètre puis les retournera (ligne 12). Pourquoi utiliser un <code class="language-plaintext highlighter-rouge">set</code> plutôt qu’une liste par exemple ? Un <code class="language-plaintext highlighter-rouge">set</code> (un <em>ensemble</em> en français) est une structure de données qui ne permet pas d’avoir des doublons. Ainsi, tous les éléments d’un set sont <em>uniques</em>. Les <code class="language-plaintext highlighter-rouge">set</code> ont d’autres propriétés, comme le fait que les éléments n’y soient pas ordonnés, et qu’il n’est pas possible d’y accéder par un indice, comme on le ferait avec une liste. Les <code class="language-plaintext highlighter-rouge">set</code> sont d’un point de vue de l’implémentation et du comportement assez proches des dictionnaires — où les éléments seraient les clefs et auxquels on attribuerait une valeur fictive. C’est d’ailleurs un des moyens d’émuler des <code class="language-plaintext highlighter-rouge">set</code> pour des langages qui n’ont pas de telle structure de données, comme en feu PHP5 ou en Perl.</p>

<p>Donc, pourquoi utiliser un <code class="language-plaintext highlighter-rouge">set</code> ? On utilise un <code class="language-plaintext highlighter-rouge">set</code>, on l’a dit, pour retirer d’éventuels doublons. Pourquoi peut-il y avoir des suggestions en double, voire triple ? Il peut y avoir plusieurs suggestions en double car plusieurs éditions différentes peuvent mener à la même correction. Imaginons que nous ayons autorisé une distance d’édition de 2, et que le mot mal orthographié est « pêhce» au lieu de « pêche ». On peut voir deux manières de le corriger :</p>

<ul>
  <li>la première est de considérer que dans « pêhce » les caractères « c » et « h » ont été transposés. Ainsi, pour corriger ce mot, il suffit d’appliquer une transposition pour inverser le « c » et le « h » et obtenir « pêche »</li>
  <li>la seconde est toujours de considérer qu’il y a bien une transposition, mais qu’au lieu de la corriger par une autre transposition, on la corrige par une délétion suivie d’une insertion (« pêhce » → « pêce » ① → « pêche » ② <em>ou</em> « pêhce » → « pêhe » ① → « pêche » ②), ou d’une insertion suivie d’une délétion (« pêhce » → « pêhche » ① → « pêche » ② <em>ou</em> « pêhce » → « pêchce » ① → « pêche » ②). Ainsi, on voit que le couple insertion/délétion peut engendrer la même correction selon l’ordre dans lequel ils sont enchaînés et le caractère sur lequel ils opèrent en premier.</li>
</ul>

<p>Ainsi, l’utilisation de <code class="language-plaintext highlighter-rouge">set</code> nous permet de retirer les doublons qui pourraient survenir dans le cas où des éditions différentes convergeraient vers la même solution.</p>

<h3 id="avancer-dans-larbre--sans-éditions">
<a class="anchor" href="#avancer-dans-larbre--sans-%C3%A9ditions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Avancer dans l’arbre : <strong>sans</strong> éditions</h3>

<p>Nous allons commencer par la partie la plus simple. Nous allons avancer dans l’arbre sans appliquer d’édition.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td>
<td class="code"><pre><span class="n">letter</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span> <span class="n">word</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
<span class="k">if</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">trie</span><span class="p">:</span>
    <span class="n">no_editions</span> <span class="o">=</span> <span class="nf">_find_closest</span><span class="p">(</span><span class="n">trie</span><span class="p">[</span><span class="n">letter</span><span class="p">],</span> <span class="n">edit_dist</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
    <span class="n">corrections</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="p">(</span><span class="n">letter</span> <span class="o">+</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">no_editions</span><span class="p">))</span>

<span class="k">if</span> <span class="n">word</span> <span class="o">==</span> <span class="sh">''</span> <span class="ow">and</span> <span class="n">trie</span> <span class="o">==</span> <span class="p">{}:</span>
    <span class="n">corrections</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="nf">set</span><span class="p">({(</span><span class="sh">""</span><span class="p">,</span> <span class="mi">0</span><span class="p">)}))</span> <span class="c1"># str: "word", int: edit_distance</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<ul>
  <li>
    <p>Nous commençons à la ligne 1 par séparer la première lettre du reste du mot.</p>

    <p>Vous pouvez noter que j’utilise les <code class="language-plaintext highlighter-rouge">slice</code> (p.ex. <code class="language-plaintext highlighter-rouge">word[2:3]</code>) pour isoler la première lettre (<code class="language-plaintext highlighter-rouge">word[0:1]</code>) du reste du mot (<code class="language-plaintext highlighter-rouge">word[1:]</code>) au lieu de l’indice du caractère dans la chaîne (p. ex. <code class="language-plaintext highlighter-rouge">word[0]</code>). En effet, s’il n’y a pas de caractère à l’indice précisé, Python lèvera une exception ; alors que lorsque l’on passe par des slices Python ne lèvera aucune exception. (‘<em>Attempting to use an index that is too large will result in an error</em>’ et ‘<em>Degenerate slice indices are handled gracefully: an index that is too large is replaced by the string size, an upper bound smaller than the lower bound returns an empty string.</em>’ la dernière phrase étant une phrase que l’on retrouve dans les vieilles documentations de Python). Ce nous évite donc d’avoir à utiliser des <code class="language-plaintext highlighter-rouge">if</code>/<code class="language-plaintext highlighter-rouge">else</code> ou <code class="language-plaintext highlighter-rouge">try</code>/<code class="language-plaintext highlighter-rouge">catch</code> :</p>
  </li>
</ul>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td>
<td class="code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="sh">"</span><span class="s">test</span><span class="sh">"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
<span class="nc">Traceback </span><span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="sh">"</span><span class="s">&lt;stdin&gt;</span><span class="sh">"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="nb">IndexError</span><span class="p">:</span> <span class="n">string</span> <span class="n">index</span> <span class="n">out</span> <span class="n">of</span> <span class="nb">range</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<ul>
  <li>
    <p>La ligne 3 <code class="language-plaintext highlighter-rouge">no_editions = _find_closest(trie[letter], edit_dist, end)</code> nous permet d’avancer de nœud en nœud dans l’arbre. A partir du nœud sur lequel nous sommes (<code class="language-plaintext highlighter-rouge">trie</code>), nous avançons vers le nœud suivant <code class="language-plaintext highlighter-rouge">trie[letter]</code> si (ligne 2) <code class="language-plaintext highlighter-rouge">trie</code> a pour clef la lettre que nous sommes en train de traiter. Si ce n’est pas le cas, alors nous ne faisons rien.</p>

    <p>Quant à <code class="language-plaintext highlighter-rouge">edit_dist</code>, cette variable nous permet de compter le nombre d’éditions que nous avons effectuées. Si nous effectuons une édition (comme nous le verrons ensuite), nous retirons 1 à <code class="language-plaintext highlighter-rouge">edit_dist</code>, ainsi, lorsque nous atteindrons 0 nous saurons qu’il n’est plus possible d’effectuer d’édition. Ici, puisque nous n’avons apporté aucune édition, nous laissons <code class="language-plaintext highlighter-rouge">edit_dist</code> tel quel. Finalement, <code class="language-plaintext highlighter-rouge">end</code> est tout simplement la fin du mot qui est passée à la fonction pour être traitée (soit pour avancer normalement comme nous le faisons ici, ou pour lui apporter une édition).</p>
  </li>
  <li>
    <p>Passons aux lignes 6 et 7, si le mot est vide <code class="language-plaintext highlighter-rouge">word == ''</code> et que l’on est sur une feuille <code class="language-plaintext highlighter-rouge">trie == {}</code>, nous remontons dans l’arbre (flèches bleues des figures précédentes). Pour que cette remontée puisse se faire correctement, nous ajoutons une valeur à <code class="language-plaintext highlighter-rouge">correction</code> (la manière d’ajouter un élément à un <code class="language-plaintext highlighter-rouge">set</code> est d’utiliser la méthode <a href="https://docs.python.org/3/library/stdtypes.html#frozenset.update"><code class="language-plaintext highlighter-rouge">update</code></a>). Ce que nous ajoutons est un <a href="https://docs.python.org/3/library/stdtypes.html#tuple"><code class="language-plaintext highlighter-rouge">tuple</code></a> de deux éléments : le premier élément de ce tuple est une chaine de caractères vide (qui servira de base pour la reconstruction du mot), et le second élément est un entier qui nous servira à compter le nombre d’éditions qui ont été appliquées. Cette valeur nous permettra de trier la liste de suggestions de corrections en la triant des mots ayant la distance d’édition la plus faible aux mots ayant la distance d’édition la plus grande.</p>
  </li>
  <li>
    <p>Terminons avec la ligne 4. Pour rappel, <code class="language-plaintext highlighter-rouge">map</code> permet d’appliquer la fonction passée en premier argument à chacun des éléments de la liste qui est indiquée en second argument (<code class="language-plaintext highlighter-rouge">no_editions</code>). Le retour de ce <code class="language-plaintext highlighter-rouge">map</code> est ensuite ajouté à <code class="language-plaintext highlighter-rouge">correction</code>.</p>

    <p>Détaillons la partie <code class="language-plaintext highlighter-rouge">lambda t: (letter + t[0], t[1])</code>. Pour rappel, les lambdas sont ce que l’on appelle des fonctions anonymes… car elles n’ont pas de nom ! La ligne précédente est équivalente à ce code :</p>
  </li>
</ul>
<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
</pre></td>
<td class="code"><pre><span class="k">def</span> <span class="nf">fonction</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="nf">return </span><span class="p">(</span><span class="n">letter</span> <span class="o">+</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></td>
</tr></tbody></table></code></pre></figure>
<p>Celle-ci prend donc un argument, nommé <code class="language-plaintext highlighter-rouge">t</code>. En réalité, <code class="language-plaintext highlighter-rouge">t</code> est un tuple de deux éléments, qui sont ceux que nous avons présentés à la ligne 7 : le premier est une chaine de caractère qui sert à reconstruire le mot en remontant dans l’arbre, et le deuxième est un entier qui stocke le nombre d’éditions. La syntaxe est un peu complexe et nous sommes obligés de passé par des indices pour accéder aux éléments du tuple, là où en Python 2 il était autorisé de faire du <em>tuple unpacking</em> dans les lambdas : <code class="language-plaintext highlighter-rouge">lambda s, e: (letter + s, e)</code> qui est plus lisible…</p>

<p>Nous voyons que nous ajoutons la lettre du nœud sur laquelle nous sommes à la chaine retournée (qui correspond à <code class="language-plaintext highlighter-rouge">t[0]</code>). Cela nous permet donc de reconstruire le mot à l’envers (comme dans les flèches bleues des figures). Pour « avocat », on part de la fin du mot avec <code class="language-plaintext highlighter-rouge">""</code> auquel on ajoute les lettres du mot en remontant : <code class="language-plaintext highlighter-rouge">""</code> →  <code class="language-plaintext highlighter-rouge">""</code> → <code class="language-plaintext highlighter-rouge">"t"</code> →  <code class="language-plaintext highlighter-rouge">"at"</code> →  <code class="language-plaintext highlighter-rouge">"cat"</code> →  <code class="language-plaintext highlighter-rouge">"ocat"</code> →  <code class="language-plaintext highlighter-rouge">"vocat"</code> →  <code class="language-plaintext highlighter-rouge">"avocat"</code>. Quant à <code class="language-plaintext highlighter-rouge">t[1]</code> la valeur reste inchangée car nous n’avons pas appliqué ici d’édition, nous nous sommes contentés d’avancer dans le mot.</p>

<p>Nous avons donc terminé la partie <em>sans éditions</em>. N’hésitez pas à relire cette partie pour bien la comprendre, puisque ce code nous servira de base par la suite pour appliquer les éditions, notamment les <code class="language-plaintext highlighter-rouge">map</code> et <code class="language-plaintext highlighter-rouge">lambda</code>. N’hésitez donc pas à jouer avec le code pour bien le comprendre <img class="emoji" title=":wink:" alt=":wink:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f609.png" height="20" width="20"></p>

<h3 id="avancer-dans-larbre--avec-éditions">
<a class="anchor" href="#avancer-dans-larbre--avec-%C3%A9ditions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Avancer dans l’arbre : <strong>avec</strong> éditions</h3>

<p>Nous allons donc passer à l’étape cruciale : l’ajout d’éditions, et nous allons commencer par gérer les délétions ou substitutions de lettres, puis nous traiterons les insertions et les transpositions. Le code sera relativement proche de celui que nous venons de voir.</p>

<h4 id="délétions-et-subsitutions">
<a class="anchor" href="#d%C3%A9l%C3%A9tions-et-subsitutions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Délétions et Subsitutions</h4>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td>
<td class="code"><pre><span class="k">if</span> <span class="n">edit_dist</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="c1"># Déletions et Subsitutions
</span>    <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">trie</span><span class="p">:</span>
        <span class="c1"># deletion (l'utilisateur a oublié de taper une lettre)
</span>        <span class="c1"># -&gt; on cherche la lettre manquante en s'autorisant à visiter tous les noeuds fils du noeud courant)
</span>        <span class="n">deletion</span> <span class="o">=</span> <span class="nf">_find_closest</span><span class="p">(</span><span class="n">trie</span><span class="p">[</span><span class="n">letter</span><span class="p">],</span> <span class="n">edit_dist</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span>
        <span class="n">deletion</span> <span class="o">=</span> <span class="nf">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="p">(</span><span class="n">letter</span> <span class="o">+</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">deletion</span><span class="p">)</span>
        <span class="n">corrections</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="n">deletion</span><span class="p">)</span>

        <span class="c1"># substitution (l'utilisateur a utilisé une lettre à la place d'un autre
</span>        <span class="c1"># -&gt; on cherche la lettre correcte en s'autorisant à visiter tous les noeuds fils du noeud courant)
</span>        <span class="k">if</span> <span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">letter</span><span class="p">:</span>
            <span class="n">substitution</span> <span class="o">=</span> <span class="nf">_find_closest</span><span class="p">(</span><span class="n">trie</span><span class="p">[</span><span class="n">letter</span><span class="p">],</span> <span class="n">edit_dist</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">word</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="n">substitution</span> <span class="o">=</span> <span class="nf">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="p">(</span><span class="n">letter</span> <span class="o">+</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">substitution</span><span class="p">)</span>
            <span class="n">corrections</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="n">substitution</span><span class="p">)</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>Nous commençons par vérifier à la ligne 1 qu’il est encore possible de faire une édition. Si tel est le cas, alors <code class="language-plaintext highlighter-rouge">edit_dist</code> sera strictement supérieur à 0. Dans le cas contraire, c’est à dire, si nous ne pouvons plus faire d’édition, nous passons directement au code que nous avons décrit à la section précédente.</p>

<p>Comme nous l’avons dit précédemment (voir <a href="#figure-deletion-substitution">cette partie</a>), pour corriger une délétion ou une substitution, nous nous autorisons à visiter tous les nœuds fils d’un nœud donné. C’est donc pour cela que nous faisons une boucle à la ligne 3 sur tous les fils (les lettres) du nœud sur lequel nous sommes. Une particularité cependant selon si l’on traite une délétion ou une substitution :</p>

<ul>
  <li>
    <p>Dans le cas d’une délétion, le but est de <strong>rajouter</strong> la lettre <strong>manquante</strong>. Ainsi, on ne touche pas à la chaine de caractères du mot que l’on traite : celle-ci reste intacte. C’est pourquoi dans ce cas, l’appel à <code class="language-plaintext highlighter-rouge">_find_closest</code> prend pour dernier argument <code class="language-plaintext highlighter-rouge">word</code>, auquel nous n’avons pas touché.</p>

    <p>Par exemple, si l’utilisateur a rentré la chaîne « avoat » et que nous sommes sur le nœud « o », la chaîne restante (<code class="language-plaintext highlighter-rouge">word</code>) est « at ». Grâce à la boucle, <code class="language-plaintext highlighter-rouge">letter</code> prendra forcément à un moment pour valeur « c ». Ainsi, il existera un appel de la fonction tel que celui-ci : <code class="language-plaintext highlighter-rouge">_find_closest(trie['c'], edit_dist - 1, "at")</code></p>
  </li>
  <li>
    <p>Dans le cas d’une substitution, le but est de <strong>rétablir</strong> la lettre erronée. Cela implique donc de ne pas prendre en compte la première lettre de la chaine que nous traitons. C’est donc pour cela que le dernier argument de <code class="language-plaintext highlighter-rouge">_find_closest</code> est <code class="language-plaintext highlighter-rouge">word[1:]</code>, c’est-à-dire la chaîne de caractères d’entrée dont la première lettre a été retirée.</p>

    <p>Par exemple, si utilisateur a rentré la chaîne « avovat » et que nous sommes sur le nœud « o », la chaîne restante (<code class="language-plaintext highlighter-rouge">word</code>) est « vat ». Grâce à la boucle, de nouveau, <code class="language-plaintext highlighter-rouge">letter</code> prendra forcément à un moment pour valeur « c ». Sauf que contrairement à la délétion, <code class="language-plaintext highlighter-rouge">letter</code> (« c » donc) devra <strong>remplacer</strong> la première lettre de la chaîne restante. C’est pourquoi donc nous n’utilisons pas <code class="language-plaintext highlighter-rouge">word</code> dans l’appel, mais <code class="language-plaintext highlighter-rouge">word[1:]</code> (« at »). Cela nous permet donc de rétablir la lettre correcte. A noter, nous avons ajouté une condition dans le cas d’une substitution, où nous n’exécutons le code que si <code class="language-plaintext highlighter-rouge">letter</code> est différent de <code class="language-plaintext highlighter-rouge">word[0:1]</code> (d’où la condition à ligne 12) puisque sinon il ne s’agirait pas d’une substitution et cela ferait doublon avec le code où l’on avance sans appliquer d’édition.</p>
  </li>
  <li>
    <p>Pour terminer, et dans les deux cas, <code class="language-plaintext highlighter-rouge">_find_closest</code> renvoie un <code class="language-plaintext highlighter-rouge">set</code> contenant (ou non, il peut être vide) la liste des corrections du mot passé en paramètre. Pour chacun des <code class="language-plaintext highlighter-rouge">set</code> de retour, nous appliquons la fonction <code class="language-plaintext highlighter-rouge">map</code> avec la même expression que nous avons vue précédemment <code class="language-plaintext highlighter-rouge">lambda t: (letter + t[0], t[1] + 1)</code>. Nous rajoutons à chacune des chaînes de caractères de retour la lettre qui permet de corriger le mot à ce stade.</p>

    <p>Un ‘détail’ cependant, l’expression n’est pas tout à fait la même, vous remarquerez que le deuxième élément du tuple est modifié cette fois-ci ! En effet, si le <code class="language-plaintext highlighter-rouge">set</code> de retour n’est pas vide c’est que nous avons effectivement appliqué une délétion ou une substitution à ce stade qui permet de corriger le mot. Il faut ainsi penser à indiquer dans le tuple de retour que nous venons de faire une édition en ajoutant 1 à la valeur contenue dans <code class="language-plaintext highlighter-rouge">t[0]</code>.</p>
  </li>
</ul>

<p>Vous vous demandez probablement pour quelles raisons le <code class="language-plaintext highlighter-rouge">set</code> de retour serait vide. Il peut être vide si les éditions que nous avons tenté d’appliquer ne mènent pas à une fin de mot. C’est par exemple le cas dans la figure présentée pour les <a href="#figure-deletion-substitution">délétions et substitutions</a> pour la tentative de correction qui a mené sur la branche du mot « avoine ». A partir du moment où l’on ne peut plus ① appliquer d’édition (<code class="language-plaintext highlighter-rouge">if edit_dist &gt; 0</code> vaut <code class="language-plaintext highlighter-rouge">False</code>) ② avancer normalement (<code class="language-plaintext highlighter-rouge">if letter in trie</code> vaut <code class="language-plaintext highlighter-rouge">False</code>) et ③ nous ne sommes pas sur une feuille (<code class="language-plaintext highlighter-rouge">if word == '' and trie == {}</code> vaut <code class="language-plaintext highlighter-rouge">False</code>) alors quoi qu’il arrive nous renvoyons <code class="language-plaintext highlighter-rouge">corrections</code> qui sera resté à sa valeur d’initialisation <code class="language-plaintext highlighter-rouge">corrections = set()</code>, c’est à dire un ensemble vide (noté <code class="language-plaintext highlighter-rouge">{}</code> en bleu dans la figure). Vous noterez que je ne le fais plus figurer ensuite dans les valeurs de retour bleues, et c’est normal, car ajouter le contenu d’un ensemble vide à un ensemble non vide … donne l’ensemble non vide de départ (pour rappel, la méthode <code class="language-plaintext highlighter-rouge">update</code> fait l’ajout <em>inplace</em>, c’est à dire, directement dans l’ensemble sur lequel on l’applique) :</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td>
<td class="code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="nf">set</span><span class="p">(</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="nf">set</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">{</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">}</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="c1"># On retrouve donc l'ensemble de départ 'a'
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="nf">set</span><span class="p">(</span><span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">{</span><span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="c1"># L'ensemble a un élément de plus !</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<h4 id="insertions-et-transpositions">
<a class="anchor" href="#insertions-et-transpositions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Insertions et Transpositions</h4>

<p>Terminons donc par corriger les insertions et transpositions. Si vous avez bien compris le code précédent, vous pouvez tenter d’écrire le code avant de lire cette partie. Code que voici :</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td>
<td class="code"><pre><span class="n">letter</span> <span class="o">=</span> <span class="n">word</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="k">if</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">trie</span><span class="p">:</span>
    <span class="c1"># insertion (l'utlisateur a ajouté une lettre en trop dans le mot)
</span>    <span class="c1"># -&gt; on s'autorise à passer au noeud de la lettre à l'indice word[1] et on ne considère pas word[0]
</span>    <span class="n">insertion</span> <span class="o">=</span> <span class="nf">_find_closest</span><span class="p">(</span><span class="n">trie</span><span class="p">[</span><span class="n">letter</span><span class="p">],</span> <span class="n">edit_dist</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">word</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
    <span class="n">corrections</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="p">(</span><span class="n">letter</span> <span class="o">+</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">insertion</span><span class="p">))</span>

    <span class="c1"># transposition
</span>    <span class="c1"># -&gt; on inverse la lettre à l'indice 1 et à l'indice 0 (on ne le fait que si word[1] est une clef)
</span>    <span class="n">transposition</span> <span class="o">=</span> <span class="nf">_find_closest</span><span class="p">(</span><span class="n">trie</span><span class="p">[</span><span class="n">letter</span><span class="p">],</span> <span class="n">edit_dist</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">word</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
    <span class="n">transposition</span> <span class="o">=</span> <span class="nf">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="p">(</span><span class="n">letter</span> <span class="o">+</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">transposition</span><span class="p">)</span>
    <span class="n">corrections</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="n">transposition</span><span class="p">)</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<ul>
  <li>On commence par récupérer la deuxième lettre de la chaîne de caractère à la ligne 1 : <code class="language-plaintext highlighter-rouge">letter = word[1:2]</code>. En effet, que l’on soit dans le cas de l’insertion ou de la transposition, le caractère qui nous intéresse pour avancer dans l’arbre est le second :
    <ul>
      <li>
        <p>Si l’utilisateur a ajouté une lettre par exemple « p » dans « avo<strong>p</strong>cat » et que nous sommes rendus au nœud « o », pour corriger l’insertion, nous ne considérons pas le premier caractère de la chaîne, en effet, nous allons essayer de sauter directement vers le second caractère pour ainsi ne pas considérer le caractère surnuméraire.</p>
      </li>
      <li>
        <p>Si l’utilisateur a fait une transposition, encore une fois c’est le second caractère qui nous intéresse. En effet, si l’utilisateur a interverti « c » et « a » dans « avo<strong>ac</strong>t » et que nous sommes sur le nœud « o », nous vérifions si le nœud « o » a pour fils le nœud « c ». Si tel est le cas, nous tentons une transposition en inversant « c » et « a » dans la chaîne et allons sur le nœud « c » pour ensuite tenter d’aller sur le nœud « a ». Dans ce cas encore une fois, c’est bien le deuxième caractère de la chaîne qui nous intéresse.
<br></p>
      </li>
    </ul>
  </li>
  <li>
    <p>Aux lignes 5 et 6, nous traitons le cas de l’insertion. Comme mentionné précédemment, nous visitons directement le nœud représentant le deuxième caractère (stocké dans <code class="language-plaintext highlighter-rouge">letter</code>) : <code class="language-plaintext highlighter-rouge">_find_closest(trie[letter], edit_dist - 1, word[2:])</code>. Cette fois-ci, nous ne passons pas la chaîne <code class="language-plaintext highlighter-rouge">word</code> intouchée, nous passons la suite de la chaine de caractère à partir du troisième caractère. Ainsi, si je reprends l’exemple « avo<strong>p</strong>cat », nous sautons le « p » et accédons directement au nœud « c », ainsi la suite de la chaîne de caractère à passer pour la suite est donc bien « at » qui commence donc au troisième caractère de la chaine (« p » : 0, « c » : 1, et « a » à l’indice 2 donc en 3e position).</p>

    <p>Comme dans les autres cas, nous mettons à jour la valeur de <code class="language-plaintext highlighter-rouge">edit_dist</code> pour signaler que nous avons appliqué une édition. Et comme dans les exemples précédents, lors du retour, nous rétablissons la lettre correcte qui est ici <code class="language-plaintext highlighter-rouge">letter</code>. La lettre surnuméraire ne sera pas ajoutée lors du retour car à aucun moment nous n’allons visiter son nœud. En effet, dans ce cas-ci nous passons directement au deuxième caractère de la chaîne, ainsi, c’est comme si le premier caractère n’avait jamais existé et il ne sera donc pas rajouté au retour.</p>
  </li>
  <li>
    <p>Les lignes 10 et 11 permettent de traiter le cas de la transposition. Le processus est relativement similaire au cas de l’insertion, sauf sur la chaîne qui est passée par la suite. Ainsi, la chaîne passée à la fonction est recomposée ainsi <code class="language-plaintext highlighter-rouge">word[0:1] + word[2:]</code> où nous collons le premier caractère de la chaîne (<code class="language-plaintext highlighter-rouge">word[0:1]</code>) au reste de la chaîne à partir du troisième caractère (<code class="language-plaintext highlighter-rouge">word[2:]</code>), le deuxième caractère étant celui qui est actuellement traité (<code class="language-plaintext highlighter-rouge">letter = word[1:2]</code>).</p>

    <p>Par exemple, prenons la chaîne  « avo<strong>ac</strong>t » et imaginons que nous sommes sur « o », ce qu’il reste à traiter est donc « act ». Le caractère que nous allons actuellement traiter (<code class="language-plaintext highlighter-rouge">letter</code>) est « c ». Ainsi, la suite de la chaîne de caractères à passer est <code class="language-plaintext highlighter-rouge">word[0]</code> (« a ») suivi de <code class="language-plaintext highlighter-rouge">word[2:]</code> (« t »), ce qui donne donc « at ». Ainsi, nous remettons les lettres dans le bon ordre, ce qui nous permet de rétablir l’orthographe correcte du mot lors du retour !</p>
  </li>
</ul>

<p>Nous avons donc terminé la méthode <code class="language-plaintext highlighter-rouge">_find_closest</code> qui est donc au cœur de l’application de correction. Le code n’est pas particulièrement compliqué une fois que l’on a compris comment utiliser l’arbre pour générer les éditions. N’hésitez pas à reprendre les diagrammes pour comprendre l’intuition sur la génération d’édition, et si le code vous pose problème, essayez de voir comment une partie du diagramme se traduit en code (par exemple, les flèches rouges, ou à quel moment les flèches bleues sont gérées dans le code).</p>

<h1 id="pour-aller-plus-loin">
<a class="anchor" href="#pour-aller-plus-loin" aria-hidden="true"><span class="octicon octicon-link"></span></a>Pour aller plus loin</h1>

<p>Notre programme de correction fonctionne, mais nous pourrions y apporter quelques améliorations :</p>

<ul>
  <li>Dans l’état actuel des choses, chaque édition à un coût fixe (de 1 : <code class="language-plaintext highlighter-rouge">edit_dist - 1</code>). Nous pourrions également imaginer pénaliser différemment chaque type d’édition. Les valeurs de pénalité devraient dans ce cas être calculées sur un corpus en regardant quelles erreurs sont les plus fréquentes. Si par exemple on se rend compte que la plupart des erreurs viennent d’une substitution ou d’une transposition, on pénaliserait moins ces éditions-ci que les autres.</li>
  <li>Dans le même ordre d’idée, on pourrait imaginer pénaliser différemment les éditions en fonction de la lettre touchée, comme le suggère Norvig. Ainsi, si l’on se rend compte que la plupart des erreurs proviennent d’un problème de doublement de lettre, on pénaliserait moins l’édition si elle consiste à doubler la lettre précédente pour rétablir l’orthographe correcte. J’imagine que c’est un cas d’erreur assez fréquent en français où les doubles lettres sont nombreuses (a<strong>ss</strong>urément, évide<strong>mm</strong>ent, o<strong>cc</strong>u<strong>rr</strong>ence, etc.).</li>
  <li>Nous présentons actuellement les propositions de correction du nombre d’éditions le plus faible au nombre d’éditions le plus haut. Cependant, dans une application réelle (un traitement de texte par exemple) nous devrions prendre en compte le contexte. Ainsi, l’on ne trierait pas seulement les mots en fonction du nombre d’éditions, mais également en fonction de la probabilité qu’ils ont d’apparaître avec le mot précédent (cela s’appelle un modèle de langue). Cela permettrait de fournir de meilleures suggestions de corrections à l’utilisateur.</li>
</ul>

<h1 id="conclusion">
<a class="anchor" href="#conclusion" aria-hidden="true"><span class="octicon octicon-link"></span></a>Conclusion</h1>

<p>Nous avons donc créé un programme de correction orthographique en utilisant des arbres <em>n</em>-aire, qui, comme nous l’avons vu, sont très pratiques et nous permettent de générer les éditions au bon moment.</p>

<p>Le programme complet est téléchargeable <a href="/assets/educational/Algorithmes_Arbres_n-aires_Correcteur-Orthographique/correcteur-orthographique.zip">ici</a> et est distribué sous licence <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank">Creative Commons 4.0 BY</a>.</p>


	</article>
	
	
	
		


		<div id="share-buttons">
			<span>Share on</span>
			<a class="facebook" title="Share this on Facebook" href="http://www.facebook.com/share.php?u=https://william-n-havard.github.io/resources/educational/algorithmes-arbres-n-aires-correcteur-orthographique/" target="_blank"><svg viewbox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1343 12v264h-157q-86 0-116 36t-30 108v189h293l-39 296h-254v759h-306v-759h-255v-296h255v-218q0-186 104-288.5t277-102.5q147 0 228 12z"></path></svg></a>
			<a class="twitter" title="Share this on Twitter" href="https://twitter.com/intent/tweet?text=https://william-n-havard.github.io/resources/educational/algorithmes-arbres-n-aires-correcteur-orthographique/" target="_blank"><svg viewbox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1684 408q-67 98-162 167 1 14 1 42 0 130-38 259.5t-115.5 248.5-184.5 210.5-258 146-323 54.5q-271 0-496-145 35 4 78 4 225 0 401-138-105-2-188-64.5t-114-159.5q33 5 61 5 43 0 85-11-112-23-185.5-111.5t-73.5-205.5v-4q68 38 146 41-66-44-105-115t-39-154q0-88 44-163 121 149 294.5 238.5t371.5 99.5q-8-38-8-74 0-134 94.5-228.5t228.5-94.5q140 0 236 102 109-21 205-78-37 115-142 178 93-10 186-50z"></path></svg></a>
			<a class="linkedin" title="Share this on Linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://william-n-havard.github.io/resources/educational/algorithmes-arbres-n-aires-correcteur-orthographique/&amp;title=&amp;summary=&amp;source=" target="_blank"><svg viewbox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M477 625v991h-330v-991h330zm21-306q1 73-50.5 122t-135.5 49h-2q-82 0-132-49t-50-122q0-74 51.5-122.5t134.5-48.5 133 48.5 51 122.5zm1166 729v568h-329v-530q0-105-40.5-164.5t-126.5-59.5q-63 0-105.5 34.5t-63.5 85.5q-11 30-11 81v553h-329q2-399 2-647t-1-296l-1-48h329v144h-2q20-32 41-56t56.5-52 87-43.5 114.5-15.5q171 0 275 113.5t104 332.5z"></path></svg></a>
			
			<a class="mail" title="Share this through Email" href="mailto:?&amp;body=https://william-n-havard.github.io/resources/educational/algorithmes-arbres-n-aires-correcteur-orthographique/" target="_blank"><svg viewbox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1792 710v794q0 66-47 113t-113 47h-1472q-66 0-113-47t-47-113v-794q44 49 101 87 362 246 497 345 57 42 92.5 65.5t94.5 48 110 24.5h2q51 0 110-24.5t94.5-48 92.5-65.5q170-123 498-345 57-39 100-87zm0-294q0 79-49 151t-122 123q-376 261-468 325-10 7-42.5 30.5t-54 38-52 32.5-57.5 27-50 9h-2q-23 0-50-9t-57.5-27-52-32.5-54-38-42.5-30.5q-91-64-262-182.5t-205-142.5q-62-42-117-115.5t-55-136.5q0-78 41.5-130t118.5-52h1472q65 0 112.5 47t47.5 113z"></path></svg></a>
		</div>
	

</div>

    </div>

    <!-- Footer -->

    
<footer class="fixed-bottom">
  <div class="container mt-0">
    <a href="#top-anchor">↑</a>
    © Copyright 2025 William N. Havard.
    Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank">GitHub Pages</a>.

    <a href="https://william-n-havard.github.io/impressum">Impressum</a>.
    
    Last updated: September 09, 2025.
    <a href="#top-anchor">↑</a>
  </div>
</footer>



  </body>

  <!-- Bootsrap & MDB scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.4.4/umd/popper.min.js" integrity="sha512-eUQ9hGdLjBjY3F41CScH3UX+4JDSI9zXeroz7hJ+RteoCaY+GP/LDoM8AO+Pt+DRFw3nXqsjh9Zsts8hnYv8/A==" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha512-M5KW3ztuIICmVIhjSqXe01oV2bpe248gOxqmlcYrEzAvws7Pw3z6BK0iGbrwvdrUQUhi3eXgtxp5I8PDo9YfjQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js" integrity="sha512-Mug9KHKmroQFMLm93zGrjhibM2z2Obg9l6qFG2qKjXEXkMp/VDkI4uju9m4QKPjWSwQ6O2qzZEnJDEeCw0Blcw==" crossorigin="anonymous"></script>

  
<!-- Mansory & imagesLoaded -->
<script defer src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
<script defer src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
<script defer src="/assets/js/mansory.js" type="text/javascript"></script>


  

<script>
	// Source: https://www.w3schools.com/howto/howto_js_scroll_indicator.asp
	// When the user scrolls the page, execute myFunction 
	window.onscroll = function() {scrollFunction()};

	function scrollFunction() {
	  var winScroll = document.body.scrollTop || document.documentElement.scrollTop;
	  var height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
	  var scrolled = (winScroll / height) * 100;
	  document.getElementById("reading-progress-bar").style.width = scrolled + "%";
	}
</script>


<!-- Medium Zoom JS -->
<script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
<script src="/assets/js/zoom.js"></script>


<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>


</html>
