<!DOCTYPE html>
<html>

  <head>
	<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>William N. Havard
	| Arbres n-aires : Auto-complétion</title>
<meta name="description" content="William N. Havard's website!">

<!-- Open Graph --><!-- Bootstrap & MDB -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css" integrity="sha512-RO38pBRxYH3SoOprtPTD86JFOclM51/XTIdEPh5j8sj4tp8jmQIx26twG52UaLi//hQldfrh7e51WzP9wuP32Q==" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css" integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

<!-- Code Syntax Highlighting -->
<link rel="stylesheet" href="/assets/css/github.css" />

<!-- Styles -->
<!--<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>W</text></svg>">-->
<link rel="icon" id="favicon" href="/assets/img/favicon/android-chrome-512x512_latin.png"/>
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="canonical" href="/resources/educational/algorithmes-arbres-n-aires-autocompletion/">

<!-- JQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>


<!-- Theming-->


<script>
	let favicon_list = ["/assets/img/favicon/android-chrome-512x512_amharic.png","/assets/img/favicon/android-chrome-512x512_arabic_waw.png","/assets/img/favicon/android-chrome-512x512_armenian.png","/assets/img/favicon/android-chrome-512x512_brahmi.png","/assets/img/favicon/android-chrome-512x512_chinese.png","/assets/img/favicon/android-chrome-512x512_coptic.png","/assets/img/favicon/android-chrome-512x512_cyrillic.png","/assets/img/favicon/android-chrome-512x512_egyptian-hieroglyphs.png","/assets/img/favicon/android-chrome-512x512_georgian.png","/assets/img/favicon/android-chrome-512x512_greek_digamma.png","/assets/img/favicon/android-chrome-512x512_gujarati.png","/assets/img/favicon/android-chrome-512x512_hangul.png","/assets/img/favicon/android-chrome-512x512_hebrew.png","/assets/img/favicon/android-chrome-512x512_hiragana.png","/assets/img/favicon/android-chrome-512x512_katakana.png","/assets/img/favicon/android-chrome-512x512_kharosthi.png","/assets/img/favicon/android-chrome-512x512_latin.png","/assets/img/favicon/android-chrome-512x512_latin_vend.png","/assets/img/favicon/android-chrome-512x512_malayalam.png","/assets/img/favicon/android-chrome-512x512_marathi.png","/assets/img/favicon/android-chrome-512x512_mongolian.png","/assets/img/favicon/android-chrome-512x512_nko.png","/assets/img/favicon/android-chrome-512x512_old-english_wynn.png","/assets/img/favicon/android-chrome-512x512_phoenician.png","/assets/img/favicon/android-chrome-512x512_runic_wunjo.png","/assets/img/favicon/android-chrome-512x512_syriac.png","/assets/img/favicon/android-chrome-512x512_tamil.png","/assets/img/favicon/android-chrome-512x512_thai.png","/assets/img/favicon/android-chrome-512x512_ugaritic.png","/assets/img/favicon/android-chrome-512x512_yiddish.png",]
	let faviconElem = document.getElementById('favicon');
	//let splitFilename = faviconElem.getAttribute('href').split('/');

	faviconElem.setAttribute('href', favicon_list[Math.floor(favicon_list.length*Math.random())]);
	//faviconElem.setAttribute('href', splitFilename.slice(0, splitFilename.length - 1).join('/') + '/' + splitFilename[splitFilename.length - 1].replace(/(.*?)(\d+)(.png)/, "$1"+Math.floor(25*Math.random())+"$3"));
</script>


<!-- MathJax -->
<script type="text/javascript">
	window.MathJax = {
	tex: {
	  tags: 'ams'
	}
	};
</script>
<script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script></head>

  <body class="fixed-top-nav ">

    <!-- Header -->

    <header>

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
	    
        
			<a class="navbar-brand title font-weight-lighter" href="https://william-n-havard.github.io/">
				<span class="font-weight-bold">William</span> N.  Havard
			</a>
        
        <!-- Navbar Toggle -->
        <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
			<span class="sr-only">Toggle navigation</span>
			<span class="icon-bar top-bar"></span>
			<span class="icon-bar middle-bar"></span>
			<span class="icon-bar bottom-bar"></span>
        </button>
        <div class="collapse navbar-collapse text-right" id="navbarNav">
			<ul class="navbar-nav ml-auto flex-nowrap">
			<!-- About -->
			<li class="nav-item ">
				<a class="nav-link" href="/">
					About
					
				</a>
			</li>
			
			<!-- Other pages -->
			
			
				
			
				
			
				
			
				
			
				
			
				
			
				
			
				
					
							<li class="nav-item ">
								<a class="nav-link" href="/publications/">
									Publications
									
								</a>
						</li>
					
				
			
				
					
							<li class="nav-item ">
								<a class="nav-link" href="/resources/">
									Resources
									
								</a>
						</li>
					
				
			
				
			
            
          </ul>
        </div>
		
			<div class="progress-container">
				<div class="progress-bar" id="reading-progress-bar"></div>
			</div>  
		
    </div>
  </nav>
</header>


    <!-- Content -->

    <div class="container mt-5">
	  <a id="top-anchor" class="invisible"></a>
      

	<div id="breadcrumb">
		<a href="/"><i class="fas fa-home"></i></a>
		  &gt; <a href="/resources/">Resources</a>
		  
		
		  &gt; <a href="/resources/educational/">Educational</a>
		  
		
		  
			&gt; Arbres n-aires : Auto-complétion
		  
		
	</div>

<div class="post">

	<header class="post-header ">
		<h1 class="post-title">Arbres n-aires : Auto-complétion</h1> 
		<div class="post-description">
			<p>Application des arbres n-aires à la création d'un programme d'auto-complétion simple en Python</p>
			<div class="container d-inline-block mx-0 mb-1 pl-0 pr-0">
				<span class="float-left">
				
					<i class="far fa-calendar-alt"></i> Posted: September 25, 2021
					
						 • <i class="far fa-calendar-check"></i> Updated: October 02, 2021
					
				
				</span>
				
	
	
		<span class="float-right"><i class="far fa-clock"></i> 51 min.</span>
	

			</div>
		</div>
	</header>
	
	<article>
		<ol id="toc" class="section-nav">
<li class="toc-entry toc-h1"><a href="#introduction">Introduction</a></li>
<li class="toc-entry toc-h1"><a href="#approche-na%C3%AFve">Approche Naïve</a></li>
<li class="toc-entry toc-h1">
<a href="#les-arbres">Les arbres</a>
<ol>
<li class="toc-entry toc-h2"><a href="#un-peu-de-terminologie">Un peu de terminologie</a></li>
<li class="toc-entry toc-h2"><a href="#un-arbre-pour-stocker-des-mots">Un arbre pour stocker des mots</a></li>
<li class="toc-entry toc-h2"><a href="#quel-int%C3%A9r%C3%AAt-">Quel intérêt ?</a></li>
</ol>
</li>
<li class="toc-entry toc-h1">
<a href="#code">Code</a>
<ol>
<li class="toc-entry toc-h2"><a href="#un-arbre-avec-un-dict">Un arbre avec un dict()</a></li>
<li class="toc-entry toc-h2"><a href="#ajouter-des-mots">Ajouter des mots</a></li>
<li class="toc-entry toc-h2">
<a href="#compter-le-nombre-de-n%C5%93uds-et-le-nombre-de-mots">Compter le nombre de nœuds et le nombre de mots</a>
<ol>
<li class="toc-entry toc-h3"><a href="#compter-les-mots">Compter les mots</a></li>
<li class="toc-entry toc-h3"><a href="#compter-les-noeuds">Compter les noeuds</a></li>
</ol>
</li>
<li class="toc-entry toc-h2">
<a href="#sugg%C3%A9rer-des-mots-%C3%A0-lutilisateur">Suggérer des mots à l’utilisateur</a>
<ol>
<li class="toc-entry toc-h3"><a href="#la-m%C3%A9thode-startswith">La méthode startswith</a></li>
<li class="toc-entry toc-h3"><a href="#la-m%C3%A9thode-_parcours">La méthode _parcours</a></li>
</ol>
</li>
</ol>
</li>
<li class="toc-entry toc-h1">
<a href="#aller-plus-loin">Aller plus loin</a>
<ol>
<li class="toc-entry toc-h2"><a href="#sur-les-arbres">Sur les arbres</a></li>
<li class="toc-entry toc-h2"><a href="#sur-la-compl%C3%A9tion">Sur la complétion</a></li>
</ol>
</li>
<li class="toc-entry toc-h1"><a href="#conclusion">Conclusion</a></li>
</ol>
<h1 id="introduction">
<a class="anchor" href="#introduction" aria-hidden="true"><span class="octicon octicon-link"></span></a>Introduction</h1>

<p>L’auto-complétion (ou <em>autocomplete</em> en anglais) désigne une fonctionnalité qui permet de suggérer à l’utilisateur un mot (ou groupe de mots) dès qu’il commence à saisir quelques caractères sur son clavier ; ceci afin de lui épargner de saisir l’ensemble du mot par lui-même. De tels programmes se trouvent notamment dans les outils classiques de traitement de texte (Word, LibreOffice, etc.) ou bien encore dans nos navigateurs (suggestions de recherche Google, Bing), nos téléphones ou bien encore, pour les plus programmeurs d’entre nous, dans la plupart des IDE modernes. Nous allons ici réaliser un programme d’auto-complétion simple en utilisant notamment un arbre <em>n</em>-aire qui permettra de stocker l’ensemble des mots du vocabulaire et nous permettra de proposer rapidement une suggestion à l’utilisateur.</p>

<p>Pour réaliser ce programme, nous aurons besoin d’un lexique. Je vous propose donc d’utiliser le lexique fourni par <a href="http://lexique.org" target="_blank">lexique.org</a>, qui a l’avantage d’être assez complet et gratuit (j’utiliserai ici la version 3.83, mais toute autre version fait aussi bien l’affaire). Vous êtes bien sûr libre d’utiliser un autre lexique (en français ou non) si vous le souhaitez.</p>

<h1 id="approche-naïve">
<a class="anchor" href="#approche-na%C3%AFve" aria-hidden="true"><span class="octicon octicon-link"></span></a>Approche Naïve</h1>

<p>Avant de comprendre l’intérêt d’utiliser des arbres, et plus particulièrement des arbres <em>n</em>-aire, nous allons essayer de voir ce que donnerait une implémentation <em>naïve</em>. Ne voyez aucun jugement de valeur dans l’utilisation du terme <em>naïf</em>, qui ici désigne simplement une implémentation non optimisée et qui est souvent la plus évidente. On va voir ici que l’implémentation naïve, même si elle fonctionne en principe, n’est pas optimale.</p>

<p>Nous souhaitons donc que lorsqu’un utilisateur commence à taper un mot, le programme lui suggère une liste de mots commençant par les caractères rentrés par l’utilisateur. La solution à laquelle nous pouvons penser serait :</p>

<ul>
  <li>
    <p>de charger tous les mots du dictionnaire dans une liste ;</p>
  </li>
  <li>
    <p>d’attendre que l’utilisateur rentre une suite de caractères ;</p>
  </li>
  <li>
    <p>de filtrer les mots de la liste en ne gardant que ceux qui commencent par les caractères rentrés par l’utilisateur.</p>
  </li>
</ul>

<p>De cette solution naïve, on peut mettre en avant deux problèmes en particulier :</p>

<ul>
  <li>Pour la recherche des suggestions tout d’abord, la <a href="https://fr.wikipedia.org/wiki/Complexit%C3%A9_en_temps" target="_blank">complexité en temps</a> en élevée : elle est en <em>O(n)</em>. Imaginons le pire cas dans lequel nous puissions nous trouver : les mots de la liste sont dans un ordre aléatoire et nous recherchons un mot commençant par « choc ». Pour retrouver l’ensemble des mots qui commencent par « choc », il est nécessaire de parcourir l’ensemble de la liste. En effet, puisque les mots de la liste sont dans un ordre aléatoire, des mots commençant par « choc » peuvent se retrouver aussi bien au début qu’à la fin de la liste, il est donc nécessaire de la parcourir en entier. Même si dans notre liste il n’y avait aucun mot qui ne commençait par « choc », nous n’aurions pas le choix et serions obligés de passer en revue tous les mots de la liste pour nous en assurer. Ainsi, si la liste contient <em>n</em> mots, il faudra donc passer en revue chacun des <em>n</em> éléments, la complexité de l’opération est donc bien en <em>O(n)</em> ;</li>
  <li>Intuitivement, nous sentons bien que la liste n’est pas une structure de données optimale. En effet, dans une liste de mots, beaucoup commencent par un préfixe commun [‘abricot’, ‘avocat’, ‘avoine’, …, ‘<strong>choc</strong>’, ‘<strong>choc</strong><em>olat</em>’, ‘<strong>choc</strong><em>olat</em>é’, …] et une simple liste ne nous permet pas de tirer parti de cela. Or, pour un programme d’autosuggestion, c’est exactement d’une structure de données qui tirerait parti de ce fait dont nous aurions besoin. Ainsi, si l’on remarque que le préfixe du mot n’a rien à voir avec l’entrée fournie par l’utilisateur, nous aimerions passer directement à des mots dont le préfixe serait celui recherché.</li>
</ul>

<p>Nous allons donc utiliser ici une structure de données spécifique qui permet de régler les problèmes que nous venons d’évoquer. Notamment, la solution proposée permettra de rechercher des suggestions intelligemment ; en effet, dans l’approche naïve, nous devons comparer le début de tous les mots de la liste à l’entrée donnée par l’utilisateur. C’est relativement peu efficace, on l’a dit, mais on ne peut faire autrement dans ce cas. L’approche proposée, qui utilise des arbres <em>n</em>-aire nous permettra de solutionner se problème en nous évitant d’avoir à comparer l’entrée de l’utilisateur à tous les mots du dictionnaire.</p>

<h1 id="les-arbres">
<a class="anchor" href="#les-arbres" aria-hidden="true"><span class="octicon octicon-link"></span></a>Les arbres</h1>

<h2 id="un-peu-de-terminologie">
<a class="anchor" href="#un-peu-de-terminologie" aria-hidden="true"><span class="octicon octicon-link"></span></a>Un peu de terminologie</h2>

<p>Tout d’abord, qu’est qu’un arbre ? Un arbre est une structure de données arborescente. Un arbre comporte un certain nombre de <em>nœuds</em> (ici représentés par des cercles). Dans un <em>arbre enraciné</em> (également appelé une <em>arborescence</em>), comme c’est le cas ici, il y a un nœud particulier, le <em>nœud racine</em> qui est le nœud qui constitue le point d’entrée de l’arbre et qui est hiérarchiquement le nœud le plus élevé.</p>

<p>Deux nœuds sont reliés entre eux par un certain nombre de branches — dans la figure ci-dessous chaque nœud a au plus <em>deux</em> branches, c’est donc un arbre <em>binaire</em> — qui permet à chaque nœud d’être relié <em>au plus</em> à deux nœuds <em>fils</em>. Il peut cependant n’avoir qu’un seul ou même zéro fils. Un nœud qui a au moins un fils est un <em>nœud interne</em> (par exemple B, C ou D), tandis qu’un nœud qui n’a pas de fils est appelé une <em>feuille</em> (ou <em>nœud externe</em>, comme J, G ou bien K). Tous les nœuds ont un <em>nœud père</em> (p.ex. D est le nœud père de G) à l’exception du nœud racine, qui par définition n’est le fils d’aucun nœud. Chaque nœud contient une certaine valeur, ici représentée par une <em>étiquette</em>.</p>

<p>Comme vous pouvez le remarquer, un arbre à une structure récursive. Ainsi le fils du nœud B — c’est-à-dire le nœud D — peut être considéré comme la racine d’un arbre plus petit qui comporterait les nœuds F, G et J. Ainsi, la zone en rouge constitue le sous-arbre (gauche) du nœud B (B n’ayant pas de fils droit, il n’a qu’un seul sous-arbre).</p>

<figure class="text-center">
  <img src="/assets/educational/Algorithmes_Arbres_n-aires_Auto-completion/terminologie_arbre.png" alt="Terminologie des arbres" class="img-fluid" style="max-width: px">
  <figcaption class="font-italic text-center">Terminologie des arbres</figcaption>
</figure>

<p>Le <em>degré</em> d’un arbre indique le nombre maximum de fils qu’un nœud peut accueillir. Ainsi, un arbre <em>unaire</em> est un arbre de degré <em>1</em> où chaque nœud ne peut avoir qu’<em>au plus</em> un seul fils (il s’agit en réalité d’une <a href="https://fr.wikipedia.org/wiki/Liste_cha%C3%AEn%C3%A9e" target="_blank">liste chaînée</a>), un arbre binaire est un arbre de degré 2 ou chaque nœud ne peut avoir qu’<em>au plus</em> 2 fils, …, un arbre <em>n</em>-aire est un arbre ou chaque nœud ne peut avoir qu’<em>au plus</em> <em>n</em> nœud fils.</p>

<h2 id="un-arbre-pour-stocker-des-mots">
<a class="anchor" href="#un-arbre-pour-stocker-des-mots" aria-hidden="true"><span class="octicon octicon-link"></span></a>Un arbre pour stocker des mots</h2>

<p>Nous allons donc nous servir d’un arbre pour stocker l’ensemble des mots du dictionnaire. Et plus particulièrement, nous allons nous servir d’un arbre <em>n</em>-aire pour les stocker. Ainsi, chaque nœud aura au plus <em>n</em> nœud fils. Plus précisément, nous allons utiliser une structure de données qui s’appelle un <em>trie</em> (de l’anglais re<em>trie</em>val) qui est, comme son nom l’indique, optimisé pour la recherche. En français, ce type d’arbre est appelé <em>arbre préfixe</em>. On peut graphiquement représenter un arbre <em>n</em>-aire comme dans la figure ci-dessous qui contient les mots suivants : « abricots », « avocat », « avoine », « ananas », « banane », « baie », « kiwi » et « kiwis » :</p>

<figure class="text-center">
  <img src="/assets/educational/Algorithmes_Arbres_n-aires_Auto-completion/arbre_n-aire.png" alt="Exemple de Trie" class="img-fluid" style="max-width: 400px">
  <figcaption class="font-italic text-center">Exemple de Trie</figcaption>
</figure>

<p>Le nœud racine est ici représenté par le nœud barré et a ici 3 nœuds fils « a », « b » et « k ». On voit que dans un tel arbre, les mots sont stockés lettre par lettre, où chaque lettre d’un mot donné est représentée par un nœud. Un nœud donné a pour nœud fils la lettre qui suit dans le mot considéré. Ainsi, si l’on parcourt, depuis le nœud racine, les nœuds situés les plus à droite, on rencontre d’abord, « k », puis « i », puis « w » puis « i », et pour finir « ∅ » ; formant ainsi le mot « kiwi∅ ». Là où le nœud racine marque le début de l’ensemble des mots stockés dans l’arbre, la fin des mots est représentée par le symbole « ∅ » (en réalité peu importe le symbole, pourvu qu’il y ait un symbole qui représente les fins de mots) ; ainsi le mot codé est « kiwi ».</p>

<p>Il est <strong>indispensable</strong> d’utiliser le caractère de fin de mot « ∅ », car il permet de savoir où se terminent les mots. En effet, sans un tel caractère, n’importe quelle suite de nœuds pourrait théoriquement constituer un mot (« abr », « anan »). On peut remarquer que cet arbre contient les mots « kiwi » et « kiwis » (le caractère ∅ suit le « i » et un autre suit le « s ») ; mais cet arbre ne contient pas le « abricot ». En effet, le caractère de fin de mot ∅ est situé après le « s » et aucun ne suit le « t ». Si l’on souhaitait que « abricot » constitue un mot, il suffirait de rajouter le caractère de fin mot à la suite du « t ».</p>

<h2 id="quel-intérêt-">
<a class="anchor" href="#quel-int%C3%A9r%C3%AAt-" aria-hidden="true"><span class="octicon octicon-link"></span></a>Quel intérêt ?</h2>

<p>En quoi utiliser un arbre <em>n</em>-aire nous permet-il de solutionner les problèmes que l’on a soulevés avec l’approche naïve ? On remarque que les préfixes communs à différents mots sont mutualisés. Par exemple, « baie » et « banane » qui partagent tous deux le préfixe « ba » partagent également les nœuds « b » et « a ». On voit que depuis l’unique nœud « a » on peut atteindre les nœuds représentant la fin des mots « banane » et « baie ». Cette structure de données permet donc de faire exactement ce que nous souhaitons, c’est-à-dire retrouver l’ensemble des mots qui commencent par un préfixe donné.</p>

<p>Maintenant, comment faire pour retrouver tous les mots qui commencent par un préfixe donné, disons « avo » ? En partant du nœud racine, on va égrener le préfixe fournit par l’utilisateur lettre à lettre pour essayer d’avancer d’un nœud à l’autre dans l’arbre. Ainsi, dans le cas où le préfixe est « avo »  il suffit de partir du nœud racine, d’aller sur le nœud représentant le « a », puis le « v », puis le « o ». Une fois arrivé sur la dernière lettre du préfixe, il va suffire de parcourir chacun de ses fils pour reconstituer les mots !</p>

<figure class="text-center">
  <img src="/assets/educational/Algorithmes_Arbres_n-aires_Auto-completion/arbre_n-aire_sous-arbre.png" alt="Sous-arbre du nœud « o » (fond rouge) contenant tous les mots commençant par le préfixe « avo »  " class="img-fluid" style="max-width: 400px">
  <figcaption class="font-italic text-center">Sous-arbre du nœud « o » (fond rouge) contenant tous les mots commençant par le préfixe « avo »  </figcaption>
</figure>

<p>Ainsi, utiliser un arbre résout notre problème :</p>

<ul>
  <li>Chercher si un préfixe existe ou non dans l’arbre ne dépend plus du nombre de mots dans l’arbre, mais seulement du nombre de lettres du préfixe. Si le préfixe existe, on fait autant d’opérations qu’il y a de lettres dans le préfixe, on est donc en <em>O(m)</em> où <em>m</em> représente le nombre de lettres du préfixe. Si le préfixe n’existe pas dans l’arbre, dans ce cas, on arrête de parcourir l’arbre dès que l’on ne peut plus avancer d’un nœud. Ainsi, si l’on cherchait le préfixe « foo » dans l’arbre, nous ne pourrions aller plus loin que le nœud racine, car celui-ci n’a aucun nœud représentant le « f ». Plus besoin donc de regarder l’ensemble des mots un à un puis de regarder si leur préfixe correspond au préfixe recherché, on ne parcourt que le sous-arbre du préfixe qui nous intéresse.</li>
  <li>Les mots sont naturellement regroupés par préfixe, et les préfixes sont mutualisés entre tous les mots qui les partagent.</li>
</ul>

<h1 id="code">
<a class="anchor" href="#code" aria-hidden="true"><span class="octicon octicon-link"></span></a>Code</h1>

<p>Pour ne pas perdre de temps et pour se focaliser sur le point clef de l’article, je vous fournis le code de l’interface (<code class="language-plaintext highlighter-rouge">interface.py</code>) et le main (<code class="language-plaintext highlighter-rouge">main.py</code>), et nous construirons la classe Trie (dans <code class="language-plaintext highlighter-rouge">trie.py</code>) ensemble. Le code complet de l’application est téléchargeable dans la <a href="#conclusion">Conclusion</a>.</p>

<h2 id="un-arbre-avec-un-dict">
<a class="anchor" href="#un-arbre-avec-un-dict" aria-hidden="true"><span class="octicon octicon-link"></span></a>Un arbre avec un <code class="language-plaintext highlighter-rouge">dict()</code>
</h2>

<p>Il y a plusieurs façons d’implémenter un arbre <em>n</em>-aire, par exemple en utilisant un classe <code class="language-plaintext highlighter-rouge">Trie</code> et une classe <code class="language-plaintext highlighter-rouge">Noeud</code> avec un attribut permettant de contenir la liste de ses enfants (ce qui est d’ailleurs le moyen de faire classique en C, à l’exception que l’on utiliserait une structure et non une classe, et un tableau plutôt qu’une liste).</p>

<p>Je vous propose ici d’implémenter un arbre <em>n</em>-aire en utilisant simplement des dictionnaires Python classiques. Ainsi, l’arbre montré dans les figures précédentes peut être avantageusement et simplement représenté par un dictionnaire ainsi :</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td>
<td class="code"><pre><span class="p">{</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">r</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">i</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">c</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">o</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">t</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">s</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">∅</span><span class="sh">'</span><span class="p">:</span> <span class="p">{}}}}}}}},</span>
       <span class="sh">'</span><span class="s">n</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">n</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">s</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">∅</span><span class="sh">'</span><span class="p">:</span> <span class="p">{}}}}}},</span>
       <span class="sh">'</span><span class="s">v</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">o</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">c</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">t</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">∅</span><span class="sh">'</span><span class="p">:</span> <span class="p">{}}}},</span> 
                   <span class="sh">'</span><span class="s">i</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">n</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">e</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">∅</span><span class="sh">'</span><span class="p">:</span> <span class="p">{}}}}}}},</span>
 <span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">i</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">e</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">∅</span><span class="sh">'</span><span class="p">:</span> <span class="p">{}}},</span> 
             <span class="sh">'</span><span class="s">n</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">n</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">e</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">∅</span><span class="sh">'</span><span class="p">:</span> <span class="p">{}}}}}}},</span>
 <span class="sh">'</span><span class="s">k</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">i</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">w</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">i</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">∅</span><span class="sh">'</span><span class="p">:</span> <span class="p">{},</span> 
                         <span class="sh">'</span><span class="s">s</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">∅</span><span class="sh">'</span><span class="p">:</span> <span class="p">{}}}}}}}</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>Dans notre implémentation un nœud est représenté par un dictionnaire. L’étiquette de ses nœuds fils sont les clefs de ce dictionnaire. La valeur associée à ces clefs est un dictionnaire qui contient les enfants de ce nœud fils (ainsi, un nœud ‘complet’ est représenté par son étiquette — la clef du dictionnaire — et la liste de ses enfants par un dictionnaire — la valeur associée à la clef). Ainsi, un arbre est un ensemble de dictionnaires imbriqués les uns dans les autres. Le dictionnaire peut éventuellement être vide, dans ce cas, cela signifie que le nœud qu’il représente n’a pas d’enfants. C’est par exemple le cas du caractère de fin de mot <code class="language-plaintext highlighter-rouge">∅</code> qui ne peut naturellement pas avoir d’enfants, puisque aucune lettre ne peut apparaître après la fin d’un mot … sinon ça n’en serait pas la fin.</p>

<p>Nous commençons donc simplement par créer une class <code class="language-plaintext highlighter-rouge">Trie</code>.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td>
<td class="code"><pre><span class="k">class</span> <span class="nc">Trie</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="sh">'</span><span class="s">∅</span><span class="sh">'</span><span class="p">,</span> <span class="n">words</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sh">"""</span><span class="s">
        Initialisation de l</span><span class="sh">'</span><span class="s">objet 
        (rappel en Python, le constructeur est __new__, __init__ n</span><span class="sh">'</span><span class="s">est qu</span><span class="sh">'</span><span class="s">un instantiateur)
        :param end: signe de fin de mot à utiliser
        :param words: liste des mots à ajouter au trie
        </span><span class="sh">"""</span>
        <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">self</span><span class="p">.</span><span class="n">end</span>  <span class="o">=</span> <span class="n">end</span>
        
        <span class="k">if</span> <span class="n">words</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">add_words</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>J’ai mis comme paramètre de l’instantiateur le caractère de fin de mot à utiliser <code class="language-plaintext highlighter-rouge">end</code> (ici <code class="language-plaintext highlighter-rouge">'∅'</code>, mais une chaîne vide marcherait tout aussi bien), ainsi que <code class="language-plaintext highlighter-rouge">words</code> qui permet de passer la liste des mots à insérer dans le Trie. Tous deux sont des paramètres optionnels.</p>

<p>La classe a donc deux attributs :</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">root</code> qui est donc le nœud racine. Comme mentionné précédemment, celui-ci est représenté par un dictionnaire ; dictionnaire qui est vide à l’initialisation, l’arbre ne contenant aucun mot.</li>
  <li>
<code class="language-plaintext highlighter-rouge">end</code> qui stockera le caractère de fin de mot</li>
</ul>

<p>A la ligne 11, nous vérifions si la liste de mots n’est pas vide (pour rappel <code class="language-plaintext highlighter-rouge">[]</code> est évalué à <code class="language-plaintext highlighter-rouge">False</code>). Si c’est bien le cas, nous faisons appel à la méthode <code class="language-plaintext highlighter-rouge">add_words</code> que nous allons créer maintenant et qui nous permettra d’ajouter l’ensemble des mots contenus dans la liste <code class="language-plaintext highlighter-rouge">words</code> au trie.</p>

<h2 id="ajouter-des-mots">
<a class="anchor" href="#ajouter-des-mots" aria-hidden="true"><span class="octicon octicon-link"></span></a>Ajouter des mots</h2>

<p>Pour ajouter des mots à notre arbre, je vous propose d’ajouter deux méthodes : une méthode <code class="language-plaintext highlighter-rouge">add_words</code> qui prendra comme argument une liste de chaînes de caractères, et une méthode <code class="language-plaintext highlighter-rouge">add_word</code> (qui sera notamment appelée par <code class="language-plaintext highlighter-rouge">add_words</code>) et qui prendra comme argument une chaîne de caractères.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td>
<td class="code"><pre><span class="k">def</span> <span class="nf">add_words</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">words</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Permet d</span><span class="sh">'</span><span class="s">ajouter DES mots au Trie
    :param words: liste de chaines de caractères
    :return: void
    </span><span class="sh">"""</span>
    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">add_word</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> 

<span class="k">def</span> <span class="nf">add_word</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Permet d</span><span class="sh">'</span><span class="s">ajouter UN mot au Trie
    :param word: chaine de caractères
    :return: void
    </span><span class="sh">"""</span>
    <span class="n">trie</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span>
    <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
        <span class="n">trie</span> <span class="o">=</span> <span class="n">trie</span><span class="p">.</span><span class="nf">setdefault</span><span class="p">(</span><span class="n">letter</span><span class="p">,</span> <span class="p">{})</span>

    <span class="n">trie</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>Détaillons un peu ce qu’il se passe dans la méthode <code class="language-plaintext highlighter-rouge">add_word</code> qui est un peu technique :</p>

<figure class="text-center">
  <img src="/assets/educational/Algorithmes_Arbres_n-aires_Auto-completion/arbre_nouveau-noeud.png" alt="Création du nouveau nœud « a », fils du nœud racine " class="img-fluid" style="max-width: 400px">
  <figcaption class="font-italic text-center">Création du nouveau nœud « a », fils du nœud racine </figcaption>
</figure>

<ul>
  <li>
    <p>On commence tout d’abord par récupérer le nœud racine que l’on stocke dans une variable : <code class="language-plaintext highlighter-rouge">trie = self.root</code> (étape ①)</p>
  </li>
  <li>
    <p>Pour chacune des lettres du préfixe entré par l’utilisateur (<code class="language-plaintext highlighter-rouge">for letter in word</code>) on va soit se déplacer sur le nœud qui correspond à la lettre <code class="language-plaintext highlighter-rouge">letter</code> en cours si ce nœud existe (dans ce cas, on va directement à l’étape ③), sinon on va créer ce nœud (étape ②) et se placer dessus (étape ③). Cette opération peut être avantageusement réalisée au moyen de la méthode <a href="https://docs.python.org/3/library/stdtypes.html#dict.setdefault" target="_blank"><code class="language-plaintext highlighter-rouge">setdefault</code></a>. Formellement, la code de la ligne 19 est équivalent à celui-ci :</p>
  </li>
</ul>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td>
<td class="code"><pre><span class="k">if</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">trie</span><span class="p">:</span>
    <span class="c1"># Le noeud sur lequel l'on est a un noeud fils correspondant à la lettre en cours
</span>    <span class="c1"># On se place donc sur ce noeud
</span>    <span class="n">trie</span> <span class="o">=</span> <span class="n">trie</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># Sinon, le noeud sur lequel l'on est n'a pas de noeud fils correspond à la lettre en cours
</span>    <span class="c1"># On ajoute une nouvelle clef (= un nouveau noeud) au noeud sur lequel on se trouve
</span>    <span class="n">trie</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Puis on se place sur le noeud nouvellement ajouté
</span>    <span class="n">trie</span> <span class="o">=</span> <span class="n">trie</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<ul>
  <li>La dernière étape (l. 21) intervient une fois le mot entièrement rentré dans le Trie, où il ne reste plus qu’à ajouter le caractère de fin de mot au nœud courant (qui est nécessairement la dernière lettre du mot).</li>
</ul>

<p>Pour mieux comprendre ce qu’il se passe, je vous invite à faire en sorte que votre programme produise une trace. Vous pouvez ce faire en ajoutant des <code class="language-plaintext highlighter-rouge">print</code> dans la version du code ci-dessus.</p>

<details>
  <summary>Afficher/Cacher le contenu masqué</summary>
  <p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td>
<td class="code"><pre><span class="k">def</span> <span class="nf">add_word</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Permet d</span><span class="sh">'</span><span class="s">ajouter UN mot au Trie
    :param word: chaine de caractères
    :return: void
    </span><span class="sh">"""</span>
    <span class="n">trie</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span>
    <span class="n">previous_node</span> <span class="o">=</span> <span class="sh">'</span><span class="s">ROOT</span><span class="sh">'</span>
    <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="se">\n</span><span class="s">Contenu du noeud {}</span><span class="sh">'</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">previous_node</span><span class="p">))</span>
        <span class="nf">pprint</span><span class="p">(</span><span class="n">trie</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">trie</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Le noeud </span><span class="sh">"</span><span class="s">{}</span><span class="sh">"</span><span class="s"> fils du noeud </span><span class="sh">"</span><span class="s">{}</span><span class="sh">"</span><span class="s"> EXISTE.</span><span class="se">\n</span><span class="sh">'</span>\
                  <span class="sh">'</span><span class="s">On se place sur le noeud </span><span class="sh">"</span><span class="s">{}</span><span class="sh">"</span><span class="s">.</span><span class="sh">'</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">letter</span><span class="p">,</span> <span class="n">previous_node</span><span class="p">,</span> <span class="n">letter</span><span class="p">))</span>
            <span class="n">trie</span> <span class="o">=</span> <span class="n">trie</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span>
            <span class="n">previous_node</span> <span class="o">=</span> <span class="n">letter</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Le noeud </span><span class="sh">"</span><span class="s">{}</span><span class="sh">"</span><span class="s"> fils du noeud </span><span class="sh">"</span><span class="s">{}</span><span class="sh">"</span><span class="s"> N</span><span class="se">\'</span><span class="s">existe PAS: </span><span class="sh">'</span>\
                  <span class="sh">'</span><span class="s">création du noeud.</span><span class="sh">'</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">letter</span><span class="p">,</span> <span class="n">previous_node</span><span class="p">))</span>
            <span class="n">trie</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">On se place sur le noeud </span><span class="sh">"</span><span class="s">{}</span><span class="sh">"</span><span class="s">.</span><span class="sh">'</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">letter</span><span class="p">))</span>
            <span class="n">trie</span> <span class="o">=</span> <span class="n">trie</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span>
            <span class="n">previous_node</span> <span class="o">=</span> <span class="n">letter</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Création du noeud </span><span class="sh">"</span><span class="s">{}</span><span class="sh">"</span><span class="s">, fils du noeud </span><span class="sh">"</span><span class="s">{}</span><span class="sh">"'</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">end</span><span class="p">,</span> <span class="n">letter</span><span class="p">))</span>
    <span class="n">trie</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Le mot {} a été rentré dans l</span><span class="se">\'</span><span class="s">arbre</span><span class="sh">'</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">word</span><span class="p">))</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">-</span><span class="sh">'</span><span class="o">*</span><span class="mi">25</span><span class="p">)</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

</p>
</details>

<h2 id="compter-le-nombre-de-nœuds-et-le-nombre-de-mots">
<a class="anchor" href="#compter-le-nombre-de-n%C5%93uds-et-le-nombre-de-mots" aria-hidden="true"><span class="octicon octicon-link"></span></a>Compter le nombre de nœuds et le nombre de mots</h2>

<p>Avant de rentrer dans le vif du sujet, à savoir, proposer des suggestions à l’utilisateur, je vous propose d’écrire deux méthodes. La première, <code class="language-plaintext highlighter-rouge">num_words</code>, permettra de compter le nombre de mots présents dans l’arbre, et la seconde, <code class="language-plaintext highlighter-rouge">num_nodes</code> permettra de compter le nombre de nœuds dans l’arbre. Cela nous permettra de nous exercer à parcourir l’arbre, et nous le ferons au moyen de <a href="https://fr.wikipedia.org/wiki/Fonction_r%C3%A9cursive" target="_blank">méthodes récursives</a>.</p>

<h3 id="compter-les-mots">
<a class="anchor" href="#compter-les-mots" aria-hidden="true"><span class="octicon octicon-link"></span></a>Compter les mots</h3>

<p>Nous allons donc commencer par créer une méthode pour compter le nombre de mots dans l’arbre. Avant de se jeter dans le code, réfléchissons : comment savons-nous où un mot s’arrête ? Nous avons défini que la fin d’un mot serait systématiquement marquée par un nœud particulier dont l’étiquette serait un caractère défini à la l’avance (dans notre cas <code class="language-plaintext highlighter-rouge">∅</code> stocké dans l’attribut <code class="language-plaintext highlighter-rouge">end</code>). Ainsi, il suffit de compter le nombre de nœuds ayant cette étiquette dans l’arbre, et nous aurons le nombre de mots !</p>

<p>Pour compter le nombre de mots, il va donc falloir parcourir toutes les branches de l’arbre. Nous allons nous servir d’une propriété que nous avons notée plus haut, la structure récursive de notre structure de données. Ainsi, le fils d’un nœud particulier peut être considéré comme la racine d’un sous-arbre plus petit. Ainsi, pour explorer complètement un arbre, il suffit d’explorer chacun de ses fils (qui constituent chacun un sous-arbre), ce qui consiste à explorer chacun des fils des fils, etc.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td>
<td class="code"><pre><span class="k">def</span> <span class="nf">num_words</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">trie</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">trie</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="k">if</span> <span class="n">trie</span> <span class="o">==</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">trie</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">end</span> <span class="ow">in</span> <span class="n">trie</span>
    <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">trie</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="nf">num_words</span><span class="p">(</span><span class="n">trie</span><span class="p">[</span><span class="n">letter</span><span class="p">])</span>
    
    <span class="k">return</span> <span class="nf">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>Analysons ce code :</p>

<ul>
  <li>A la ligne 2 nous nous plaçons sur le nœud passé en paramètre. Si aucun nœud n’est passé en paramètre, nous nous plaçons sur le nœud racine <code class="language-plaintext highlighter-rouge">self.root</code>.</li>
  <li>A la ligne 4, nous déclarons une variable <code class="language-plaintext highlighter-rouge">n</code> et plaçons dans la variable la valeur retournée par <code class="language-plaintext highlighter-rouge">self.end in trie</code>. Ce que nous faisons ici, c’est que nous regardons si le nœud sur lequel nous nous trouvons (nœud qui est stocké dans la variable <code class="language-plaintext highlighter-rouge">trie</code>) a un fils qui aurait pour étiquette « ∅ » (<code class="language-plaintext highlighter-rouge">self.end</code>). Si c’est le cas, alors <code class="language-plaintext highlighter-rouge">self.end in trie</code> vaut <code class="language-plaintext highlighter-rouge">True</code> qui est évalué à <code class="language-plaintext highlighter-rouge">1</code> par Python (par exemple si nous sommes sur le « i » de « kiwi »). Dans le cas, contraire,  <code class="language-plaintext highlighter-rouge">self.end in trie</code> vaut <code class="language-plaintext highlighter-rouge">False</code> qui est évalué à <code class="language-plaintext highlighter-rouge">0</code> par Python (par exemple, si nous sommes sur le « w » de « kiwi », car « w » n’a qu’un seul fils — « i » — qui n’est pas le caractère de fin de mot). Si cette façon de faire ne vous paraît pas très intuitive, vous pouvez la remplacer par celle-ci qui est plus intuitive lorsque l’on débute :</li>
</ul>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td>
<td class="code"><pre><span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">end</span> <span class="ow">in</span> <span class="n">trie</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<ul>
  <li>A la ligne 5, nous allons parcourir chacun des fils du nœud sur lequel nous nous trouvons, qui, pour rappel, aura pour étiquette <code class="language-plaintext highlighter-rouge">letter</code>
</li>
  <li>A la ligne 6, nous réalisons un appel récursif (la méthode s’appelle elle-même). Cette fois-ci, nous lui donnons un paramètre : l’arbre qu’il faut explorer ensuite. Pour ce faire rien de plus simple, nous passons le dictionnaire lié à l’étiquette qui nous intéresse <code class="language-plaintext highlighter-rouge">trie[letter]</code>. Et la fonction sera appelée autant de fois que le nœud sur lequel nous sommes a de fils, de même pour les fils de chacun des fils, etc. Si un nœud n’a pas de fils, alors il n’y aura rien à explorer et nous arrêterons donc de faire un appel récursif (puis que nous ne rentrerons même pas dans la boucle de la ligne 5)</li>
  <li>Pour finir, nous ajoutons ce que la méthode nous renverra à la variable <code class="language-plaintext highlighter-rouge">n</code> ; variable que nous retournons à la ligne 8.</li>
</ul>

<p>Ici, nous sommes assurés que la fonction récursive s’arrêtera puisque celle-ci est appelée pour chaque fils d’un nœud donné. Etant donné qu’un nœud n’a qu’un nombre fini de fils, nous sortirons forcément de la boucle de la ligne 5.</p>

<p>Maintenant que nous avons cette méthode, nous allons en profiter pour faire une assertion dans l’instantiateur et vérifier que l’arbre contient bien autant de mots que le nombre de mots qu’il y avait à ajouter.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
</pre></td>
<td class="code"><pre><span class="c1"># Code à rajouter à la suite de la ligne 14 de l'instantiateur
</span><span class="err">​</span>    <span class="k">assert</span> <span class="nf">len</span><span class="p">(</span><span class="nf">set</span><span class="p">(</span><span class="n">words</span><span class="p">))</span> <span class="o">==</span> <span class="n">self</span><span class="p">.</span><span class="nf">num_words</span><span class="p">(),</span> <span class="sh">"</span><span class="s">Problème à la construction du Trie : mots manquants !</span><span class="sh">"</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>Ce code nous permet de nous assurer que l’arbre contient bien autant de mots qu’il y en a dans la liste passée en entrée (et si ce n’est pas le cas, nous signalons l’erreur à l’utilisateur et arrêtons le programme.)</p>

<h3 id="compter-les-noeuds">
<a class="anchor" href="#compter-les-noeuds" aria-hidden="true"><span class="octicon octicon-link"></span></a>Compter les noeuds</h3>

<p>Compter le nombre de nœuds dans l’arbre revient à écrire un code quasiment identique à celui que nous venons d’écrire. La seule différence est ici à la ligne 4. Ici, nous initialisons directement <code class="language-plaintext highlighter-rouge">n</code> a 1. En effet, à partir du moment où cette fonction est appelée, c’est que nous sommes sur au moins un nœud. Même si l’arbre ne contient aucun mot, il y a au moins un nœud : le nœud racine.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td>
<td class="code"><pre><span class="k">def</span> <span class="nf">num_nodes</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">trie</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">trie</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="k">if</span> <span class="n">trie</span> <span class="o">==</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">trie</span>

    <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">trie</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="nf">num_nodes</span><span class="p">(</span><span class="n">trie</span><span class="p">[</span><span class="n">letter</span><span class="p">])</span>
    
    <span class="k">return</span> <span class="n">n</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<h2 id="suggérer-des-mots-à-lutilisateur">
<a class="anchor" href="#sugg%C3%A9rer-des-mots-%C3%A0-lutilisateur" aria-hidden="true"><span class="octicon octicon-link"></span></a>Suggérer des mots à l’utilisateur</h2>

<p>Maintenant que nous avons ajouté des mots à l’arbre et que nous savons parcourir l’arbre de façon récursive, nous avons toutes les clefs en main pour suggérer des mots à l’utilisateur. Je vous propose donc de créer une méthode <code class="language-plaintext highlighter-rouge">startswith</code> qui prendra comme un argument un préfixe (une chaîne de caractères) et qui renverra l’ensemble des mots dans l’arbre qui commencent par le préfixe donné.</p>

<h3 id="la-méthode-startswith">
<a class="anchor" href="#la-m%C3%A9thode-startswith" aria-hidden="true"><span class="octicon octicon-link"></span></a>La méthode <code class="language-plaintext highlighter-rouge">startswith</code>
</h3>

<p>La première chose que nous allons faire dans la méthode <code class="language-plaintext highlighter-rouge">startswith</code> va consister à vérifier que le préfixe entré par l’utilisateur existe dans l’arbre. Si ce n’est pas le cas, nous renverrons une liste vide, dans le cas contraire, nous peuplerons cette liste avec l’ensemble des mots qui commencent par le préfixe donné. Voici le code de l’ensemble de la méthode <code class="language-plaintext highlighter-rouge">startswith</code> que nous allons détailler ci-après.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td>
<td class="code"><pre><span class="k">def</span> <span class="nf">startswith</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Permet de retrouver tous les mots qui commencent avec le préfixe `prefix`
    :param prefix: chaine de caractères
    :return: set de chaines de caractères
    </span><span class="sh">"""</span>
    <span class="n">trie</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span>
    <span class="n">suggestions</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Pour chacune des lettres du préfixe
</span>    <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">prefix</span><span class="p">:</span>
        <span class="c1"># On essaye d'avancer dans l'arbre
</span>        <span class="k">if</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">trie</span><span class="p">:</span>
            <span class="n">trie</span> <span class="o">=</span> <span class="n">trie</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Si on n'y arrive pas, on retourne un set vide
</span>            <span class="k">return</span> <span class="n">suggestions</span>
    
    <span class="c1"># Si on est là, le préfixe existe bien dans l'arbre !
</span>    <span class="c1"># Il ne reste plus qu'à parcourir chacune des branches et reconstruire l'ensemble des mots
</span>    <span class="n">suggestions</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">suffix</span><span class="p">:</span> <span class="n">prefix</span><span class="o">+</span><span class="n">suffix</span><span class="p">,</span> <span class="nf">list</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">_parcours</span><span class="p">(</span><span class="n">trie</span><span class="p">))))</span>
    
    <span class="c1"># Et on retourne le tout
</span>    <span class="k">return</span> <span class="n">suggestions</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<ul>
  <li>
    <p>A la ligne 7, nous nous plaçons sur la racine de l’arbre, comme nous l’avons fait dans les codes précédents</p>
  </li>
  <li>
    <p>A la ligne 8, nous déclarons une liste (pour l’instant vide) qui nous permettra de stocker l’ensemble des mots qui commencent par le préfixe spécifié par l’utilisateur</p>
  </li>
  <li>
    <p>De la ligne 11 à ligne 17, nous vérifions que le préfixe rentré par l’utilisateur existe bel et bien dans l’arbre. Pour ce faire, nous parcourons l’arbre en regardant lettre à lettre le préfixe spécifié par l’utilisateur. A partir du moment où nous sommes bloqués sur un nœud (la lettre en cours ne n’est pas une étiquette d’un nœud fils du nœud sur lequel nous sommes), nous retournons la liste de suggestions, qui est restée vide. Sinon, nous avançons de nœud en nœud dans l’arbre.</p>
  </li>
  <li>
    <p>La ligne 21 est la ligne qui nous permet de récupérer l’ensemble des suggestions pour le préfixe donné. Elle fait appel à la méthode <code class="language-plaintext highlighter-rouge">_parours</code> que nous allons détailler ensuite. Cette méthode prend comme argument un nœud, qui est le nœud qui correspond à la dernière lettre du préfixe. En effet, ce que nous souhaitons faire est explorer l’ensemble des nœuds fils de la dernière lettre afin de récupérer l’ensemble des fins de mots. Ainsi, <code class="language-plaintext highlighter-rouge">list(self._parcours(trie))</code> va contenir l’ensemble des suffixes possibles pour un préfixe donné. Ce qu’il nous reste à faire de recomposer les mots en ‘collant’ le préfixe fourni par l’utilisateur à chacun des suffixes qui auront été retrouvés. C’est ce que permet de faire la fonction <code class="language-plaintext highlighter-rouge">map</code> (cf. la <a href="https://docs.python.org/3/library/functions.html#map" target="_blank">documentation de Python</a>). Et pour finir, nous ajoutons l’ensemble des mots reconstitués à la liste de suggestions, que nous renvoyons à la ligne 24.</p>

    <p>Pour information, et pour mieux comprendre la fonction <code class="language-plaintext highlighter-rouge">map</code> vous pouvez faire tourner ce code :</p>
  </li>
</ul>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td>
<td class="code"><pre><span class="n">prefixe</span> <span class="o">=</span> <span class="sh">"</span><span class="s">avo</span><span class="sh">"</span>
<span class="n">suggestions</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">suffixe</span><span class="p">:</span> <span class="n">prefixe</span><span class="o">+</span><span class="n">suffixe</span><span class="p">,</span> <span class="p">[</span><span class="sh">'</span><span class="s">ine</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">cat</span><span class="sh">'</span><span class="p">]))</span>
<span class="nf">print</span><span class="p">(</span><span class="n">suggestions</span><span class="p">)</span>
<span class="p">[</span><span class="sh">'</span><span class="s">avoine</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">avocat</span><span class="sh">'</span><span class="p">]</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>Qui nous retourne bien <code class="language-plaintext highlighter-rouge">['avoine', 'avocat']</code>. Ainsi, pour chaque suffixe (<code class="language-plaintext highlighter-rouge">['ine', 'cat']</code>) nous avons collé le préfixe <code class="language-plaintext highlighter-rouge">'avo'</code> à chacun d’eux, ce qui nous a permis de former les mots précédemment cités. L’opération de collage a été effectuée par une <a href="https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions" target="_blank">expression lambda</a> qui permet de faire des fonctions anonymes. Formellement, le code précédent est équivalent à celui-ci :</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td>
<td class="code"><pre><span class="k">def</span> <span class="nf">coller</span><span class="p">(</span><span class="n">suffixe</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">prefixe</span> <span class="o">+</span> <span class="n">suffixe</span>

<span class="n">prefixe</span> <span class="o">=</span> <span class="sh">"</span><span class="s">avo</span><span class="sh">"</span>
<span class="n">suggestions</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="n">coller</span><span class="p">,</span> <span class="p">[</span><span class="sh">"</span><span class="s">ine</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">cat</span><span class="sh">"</span><span class="p">]))</span>
<span class="nf">print</span><span class="p">(</span><span class="n">suggestions</span><span class="p">)</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>Ainsi, l’expression lambda nous a permis “d’économiser du code” en nous évidant d’avoir à déclarer une fonction <em>ad-hoc</em> qui n’aurait été utile que dans ce cas.</p>

<h3 id="la-méthode-_parcours">
<a class="anchor" href="#la-m%C3%A9thode-_parcours" aria-hidden="true"><span class="octicon octicon-link"></span></a>La méthode <code class="language-plaintext highlighter-rouge">_parcours</code>
</h3>

<p>Il nous reste maintenant à écrire la méthode <code class="language-plaintext highlighter-rouge">_parcours</code> qui nous permettra de récupérer l’ensemble des suffixes d’un préfixe donné. Pour rappel, les méthodes préfixées du soulignement <code class="language-plaintext highlighter-rouge">_</code> sont considérées comme des méthodes privées en Python. Tout comme les fonctions <code class="language-plaintext highlighter-rouge">num_words</code> et <code class="language-plaintext highlighter-rouge">num_nodes</code>, cette méthode sera récursive.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td>
<td class="code"><pre><span class="k">def</span> <span class="nf">_parcours</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">trie</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Permet de parcourir le Trie récursivement
    :param trie: Un dictionnaire représentant le noeud à explorer
    :return: set de chaines de caractères
    </span><span class="sh">"""</span>
    <span class="n">suffix</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Est-on sur une feuille ?
</span>    <span class="k">if</span> <span class="n">trie</span> <span class="o">==</span> <span class="p">{}:</span>
        <span class="k">return</span> <span class="p">[</span><span class="sh">""</span><span class="p">]</span>
    
    <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">trie</span><span class="p">:</span>
        <span class="n">suffix</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">suffix</span><span class="p">:</span> <span class="n">letter</span> <span class="o">+</span> <span class="n">suffix</span><span class="p">,</span> <span class="nf">list</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">_parcours</span><span class="p">(</span><span class="n">trie</span><span class="p">[</span><span class="n">letter</span><span class="p">]))))</span>
    
    <span class="k">return</span> <span class="n">suffix</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>Cette méthode prend en entrée le nœud duquel on souhaite obtenir le sous-arbre ; sous-arbre que nous appelons <code class="language-plaintext highlighter-rouge">trie</code>. Détaillons les points importants de ce code :</p>

<ul>
  <li>
    <p>La ligne 10 est la ligne cruciale de ce code ! Nous regardons si le nœud sur lequel nous sommes est une feuille, auquel cas, c’est que nous serions arrivés au bout d’un mot. Si tel est le cas, nous renvoyons une liste contenant une chaîne vide <code class="language-plaintext highlighter-rouge">""</code>. Celle-ci sera la base du mot que nous reconstruirons récursivement lettre par lettre.</p>
  </li>
  <li>
    <p>Les lignes 13 et 14 sont les lignes qui permettent d’explorer le reste de l’arbre de manière récursive. Notez que nous faisons appel à la méthode <code class="language-plaintext highlighter-rouge">_parcours</code> pour chacun des nœuds fils sur lequel nous sommes. Contrairement au fonction <code class="language-plaintext highlighter-rouge">num_nodes</code> et <code class="language-plaintext highlighter-rouge">num_words</code> où nous faisions un simple appel récursif sans plus traiter les données de retour (mis à part une simple addition), ici les données de retour passent par la fonction <code class="language-plaintext highlighter-rouge">map</code>. Ce que nous faisons ici, c’est que nous ajoutons au début de la chaîne l’étiquette du nœud dont nous venons d’explorer les enfants.</p>
  </li>
</ul>

<p>Pour mieux comprendre comment les mots sont (re)construits de manière récursive, voici une figure illustrant le processus :</p>

<figure class="text-center">
  <img src="/assets/educational/Algorithmes_Arbres_n-aires_Auto-completion/arbre_n-aire_recursion.png" alt="(Re)Construire des mots de façon récursive" class="img-fluid" style="max-width: 800px">
  <figcaption class="font-italic text-center">(Re)Construire des mots de façon récursive</figcaption>
</figure>

<ul>
  <li>Admettons que le préfixe fourni par l’utilisateur est «  avo », nous parcourons tout d’abord l’arbre à partir de la racine et allons de nœud en nœud jusqu’au nœud représentant le « o », où sommes arrivés à la dernière lettre du préfixe (chemin en noir dans la figure, le code qui fait cela est dans la méthode <code class="language-plaintext highlighter-rouge">startswith</code> de la ligne 11 à 17).</li>
  <li>A partir de là, il faut récupérer les suffixes possibles à partir du nœud sur lequel nous sommes (ici indiqués en rouge, nous le faisons grâce à la méthode <code class="language-plaintext highlighter-rouge">_parcours</code> appelée par <code class="language-plaintext highlighter-rouge">startswith</code> à la ligne 21).</li>
  <li>La première chose que fait <code class="language-plaintext highlighter-rouge">_parcours</code> est de vérifier si le nœud que nous explorons est une feuille, ce qui voudrait dire, que par définition il n’aurait pas de fils, donc <code class="language-plaintext highlighter-rouge">trie == {}</code>. Si tel est le cas, nous renvoyons une liste contenant une chaîne vide qui sera la base du mot à reconstruire (ligne 11). Cette opération déclenche la « remontée » de la branche parcourue et est figurée en bleu. Lors de la remontée, nous allons ajouter l’étiquette du nœud dont nous venons d’explorer les fils à l’ensemble des chaînes de caractères retournées. Cela se fait au moyen de la fonction <code class="language-plaintext highlighter-rouge">map</code>. De nouveau nous utilisons une expression lambda <code class="language-plaintext highlighter-rouge">lambda suffix: letter + suffix</code> où <code class="language-plaintext highlighter-rouge">suffix</code> prendra alternativement pour valeur chacun des chaînes de caractères de la liste <code class="language-plaintext highlighter-rouge">list(self._pacours(trie[letter]))</code> .</li>
  <li>Si ne nous sommes pas sur une feuille, nous explorons chacun des fils du nœud sur lequel nous sommes (ligne 14 au moyen de l’appel récursif, symbolisé par des flèches rouges dans la figure : <code class="language-plaintext highlighter-rouge">self._parcours(trie[letter])</code>).</li>
  <li>Ainsi, à la ligne 21 de <code class="language-plaintext highlighter-rouge">startwith</code>, la liste de retour obtenue contient deux éléments <code class="language-plaintext highlighter-rouge">["cat", "ine"]</code>, pour lesquels nous n’avons plus qu’à préfixer le préfixe fourni par l’utilisateur, comme détaillé précédemment.</li>
</ul>

<p>Voici une trace de la méthode parcours pour que vous puissiez comprendre son fonctionnement plus en détail.</p>

<details>
  <summary>Afficher/Cacher le contenu masqué</summary>
  <p>
</p>
<pre>
ALLER 0e appel de la méthode _parcours (exploration des fils du noeud o, 0/2 fils explorés) suffix=[]
| ALLER 1e appel de la méthode _parcours (exploration des fils du noeud c, 0/1 fils explorés) suffix=[]
| | ALLER 2e appel de la méthode _parcours (exploration des fils du noeud a, 0/1 fils explorés) suffix=[]
| | | ALLER 3e appel de la méthode _parcours (exploration des fils du noeud t, 0/1 fils explorés) suffix=[]
| | | | ALLER 4e appel de la méthode _parcours (exploration des fils du noeud ∅, 0/0 fils explorés) suffix=[]
| | | | RETOUR Fin de mot !
| | | RETOUR 3e appel de la méthode _parcours (exploration des fils du noeud t, 1/1 fils explorés) lettre ajoutée : ∅ | suffix=['∅']
| | RETOUR 2e appel de la méthode _parcours (exploration des fils du noeud a, 1/1 fils explorés) lettre ajoutée : t | suffix=['t∅']
| RETOUR 1e appel de la méthode _parcours (exploration des fils du noeud c, 1/1 fils explorés) lettre ajoutée : a | suffix=['at∅']
RETOUR 0e appel de la méthode _parcours (exploration des fils du noeud o, 1/2 fils explorés) lettre ajoutée : c | suffix=['cat∅']
| ALLER 1e appel de la méthode _parcours (exploration des fils du noeud i, 0/1 fils explorés) suffix=[]
| | ALLER 2e appel de la méthode _parcours (exploration des fils du noeud n, 0/1 fils explorés) suffix=[]
| | | ALLER 3e appel de la méthode _parcours (exploration des fils du noeud e, 0/1 fils explorés) suffix=[]
| | | | ALLER 4e appel de la méthode _parcours (exploration des fils du noeud ∅, 0/0 fils explorés) suffix=[]
| | | | RETOUR Fin de mot !
| | | RETOUR 3e appel de la méthode _parcours (exploration des fils du noeud e, 1/1 fils explorés) lettre ajoutée : ∅ | suffix=['∅']
| | RETOUR 2e appel de la méthode _parcours (exploration des fils du noeud n, 1/1 fils explorés) lettre ajoutée : e | suffix=['e∅']
| RETOUR 1e appel de la méthode _parcours (exploration des fils du noeud i, 1/1 fils explorés) lettre ajoutée : n | suffix=['ne∅']
RETOUR 0e appel de la méthode _parcours (exploration des fils du noeud o, 2/2 fils explorés) lettre ajoutée : i | suffix=['cat∅', 'ine∅']
</pre>


</details>

<p>On peut remarquer un léger problème : le caractère de fin de mot <code class="language-plaintext highlighter-rouge">∅</code> est ajouté aux chaînes de caractères. C’est tout à faire normal. En effet, notre critère pour renvoyer la chaîne de caractère qui servira à reconstruire le mot lors de la remontée, est de visiter un nœud qui n’a pas d’enfants, et où la variable <code class="language-plaintext highlighter-rouge">trie</code> à explorer est donc <code class="language-plaintext highlighter-rouge">{}</code>. Or, cette condition n’est réunie que pour un nœud : le nœud ayant <code class="language-plaintext highlighter-rouge">∅</code> pour étiquette. Ainsi, cela implique à un moment de la récursion de faire un appel du type <code class="language-plaintext highlighter-rouge">self._pacours(trie['∅']))</code> à la ligne 14. Or, à la ligne 14, nous ajoutons par défaut l’étiquette du nœud que nous venons d’explorer, d’où l’ajout du caractère <code class="language-plaintext highlighter-rouge">∅</code>. Il existe donc deux solutions pour ne pas avoir ce caractère :</p>

<ul>
  <li>changer le caractère de fin de mot par une chaîne vide (à faire à la construction de l’arbre dans le fichier <code class="language-plaintext highlighter-rouge">main.py</code> à la ligne 10)</li>
  <li>changer les lignes 10 et 11 de <code class="language-plaintext highlighter-rouge">_parcours</code> par le code ci-dessous. Attention, il pas de <code class="language-plaintext highlighter-rouge">return suffix</code> dans ce cas, car un nœud peu avoir à la fois un enfant <code class="language-plaintext highlighter-rouge">∅</code> mais également d’autres enfants… Si nous faisions un <code class="language-plaintext highlighter-rouge">return</code> ici, nous n’explorerions pas tous les enfants !</li>
</ul>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
</pre></td>
<td class="code"><pre><span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">end</span> <span class="ow">in</span> <span class="n">trie</span><span class="p">:</span>
    <span class="n">suffix</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="sh">""</span><span class="p">)</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>Nous en avons donc fini avec la méthode <code class="language-plaintext highlighter-rouge">_parcours</code> qui ne présente pas nécessairement de difficulté particulière d’un point de vue technique, mais probablement un peu plus d’un point de vue conceptuel, si vous n’êtes pas familier de la récursion.</p>

<h1 id="aller-plus-loin">
<a class="anchor" href="#aller-plus-loin" aria-hidden="true"><span class="octicon octicon-link"></span></a>Aller plus loin</h1>

<p>Voici quelques idées pour aller plus loin sur la manipulation des arbres ou sur la complétion en elle-même.</p>

<h2 id="sur-les-arbres">
<a class="anchor" href="#sur-les-arbres" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sur les arbres</h2>

<ul>
  <li>
    <p>Créer une méthode qui permet de savoir si un mot est présent ou non dans l’arbre. Redéfinir <code class="language-plaintext highlighter-rouge">__contains__</code> semble être une bonne idée. Ce va permettre d’écrire du code Python plus idiomatique par la suite, par exemple <code class="language-plaintext highlighter-rouge">if 'William' in trie</code> plutôt que <code class="language-plaintext highlighter-rouge">if trie.has_word('William')</code> qui est moins idiomatique.</p>
  </li>
  <li>
    <p>Écrire une méthode permettant de supprimer un mot. Attention, lorsqu’on supprime un mot, il faut non seulement enlever le caractère de fin de mot <code class="language-plaintext highlighter-rouge">∅</code>, mais également les nœuds qui ne servent plus … mais attention a ne pas en supprimer trop. Si par exemple on souhaitait supprimer le mot « kiwis » (pluriel) il faudrait d’abord supprimer le nœud <code class="language-plaintext highlighter-rouge">∅</code> puis le nœud <code class="language-plaintext highlighter-rouge">s</code> mais pas le reste, en effet, les nœuds « k », « i », « w », « i » et « ∅ » servent encore à former le mot « kiwi » (singulier).</p>
  </li>
</ul>

<h2 id="sur-la-complétion">
<a class="anchor" href="#sur-la-compl%C3%A9tion" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sur la complétion</h2>

<p>Notre approche est assez rudimentaire dans la présentation des suggestions, et notamment, ici les suggestions vont du mot le plus long au mot le plus court.</p>

<ul>
  <li>
    <p>Est-ce vraiment un approche pertinente ? A priori, l’ordre des suggestions devrait non seulement être dicté par le nombre de caractères économisés (que l’utilisateur n’aura pas écrire) mais aussi par la fréquence des mots (fréquence calculé sur un corpus représentatif du français). Pour stocker la fréquence d’un mot, rien de plus simple, il suffit de le stocker dans le nœud de fin de mot <code class="language-plaintext highlighter-rouge">∅</code> !</p>
  </li>
  <li>
    <p>Dans une application réelle, on suggère les mots non seulement en fonction du préfixe rentré, mais également des mots précédents. Il serait donc opportun d’ajouter un modèlé de langue pour trier la liste de suggestions en fonction de leur probabilité et du nombre de lettres économisées.</p>
  </li>
</ul>

<h1 id="conclusion">
<a class="anchor" href="#conclusion" aria-hidden="true"><span class="octicon octicon-link"></span></a>Conclusion</h1>

<p>Nous avons réalisé un programme d’auto-complétion en Python grâce à des arbres <em>n</em>-aires, qui, comme nous l’avons noté, sont plus efficaces qu’une simple liste. Si vous ne connaissiez pas déjà la notion d’« arbre » en algorithmique, cet article était probablement assez dense ; je vous invite dans ce cas à le reprendre étape par étape, et pour bien faire, sans regarder la correction <img class="emoji" title=":wink:" alt=":wink:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f609.png" height="20" width="20"></p>

<p>Le programme complet est téléchargeable <a href="/assets/educational/Algorithmes_Arbres_n-aires_Auto-completion/auto-completion.zip">ici</a> et est distribué sous licence <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank">Creative Commons 4.0 BY</a>.</p>


	</article>
	
	
	
		


		<div id="share-buttons">
			<span>Share on</span>
			<a class="facebook" title="Share this on Facebook" href="http://www.facebook.com/share.php?u=https://william-n-havard.github.io/resources/educational/algorithmes-arbres-n-aires-autocompletion/" target="_blank"><svg viewbox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1343 12v264h-157q-86 0-116 36t-30 108v189h293l-39 296h-254v759h-306v-759h-255v-296h255v-218q0-186 104-288.5t277-102.5q147 0 228 12z"></path></svg></a>
			<a class="twitter" title="Share this on Twitter" href="https://twitter.com/intent/tweet?text=https://william-n-havard.github.io/resources/educational/algorithmes-arbres-n-aires-autocompletion/" target="_blank"><svg viewbox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1684 408q-67 98-162 167 1 14 1 42 0 130-38 259.5t-115.5 248.5-184.5 210.5-258 146-323 54.5q-271 0-496-145 35 4 78 4 225 0 401-138-105-2-188-64.5t-114-159.5q33 5 61 5 43 0 85-11-112-23-185.5-111.5t-73.5-205.5v-4q68 38 146 41-66-44-105-115t-39-154q0-88 44-163 121 149 294.5 238.5t371.5 99.5q-8-38-8-74 0-134 94.5-228.5t228.5-94.5q140 0 236 102 109-21 205-78-37 115-142 178 93-10 186-50z"></path></svg></a>
			<a class="linkedin" title="Share this on Linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://william-n-havard.github.io/resources/educational/algorithmes-arbres-n-aires-autocompletion/&amp;title=&amp;summary=&amp;source=" target="_blank"><svg viewbox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M477 625v991h-330v-991h330zm21-306q1 73-50.5 122t-135.5 49h-2q-82 0-132-49t-50-122q0-74 51.5-122.5t134.5-48.5 133 48.5 51 122.5zm1166 729v568h-329v-530q0-105-40.5-164.5t-126.5-59.5q-63 0-105.5 34.5t-63.5 85.5q-11 30-11 81v553h-329q2-399 2-647t-1-296l-1-48h329v144h-2q20-32 41-56t56.5-52 87-43.5 114.5-15.5q171 0 275 113.5t104 332.5z"></path></svg></a>
			
			<a class="mail" title="Share this through Email" href="mailto:?&amp;body=https://william-n-havard.github.io/resources/educational/algorithmes-arbres-n-aires-autocompletion/" target="_blank"><svg viewbox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1792 710v794q0 66-47 113t-113 47h-1472q-66 0-113-47t-47-113v-794q44 49 101 87 362 246 497 345 57 42 92.5 65.5t94.5 48 110 24.5h2q51 0 110-24.5t94.5-48 92.5-65.5q170-123 498-345 57-39 100-87zm0-294q0 79-49 151t-122 123q-376 261-468 325-10 7-42.5 30.5t-54 38-52 32.5-57.5 27-50 9h-2q-23 0-50-9t-57.5-27-52-32.5-54-38-42.5-30.5q-91-64-262-182.5t-205-142.5q-62-42-117-115.5t-55-136.5q0-78 41.5-130t118.5-52h1472q65 0 112.5 47t47.5 113z"></path></svg></a>
		</div>
	

</div>

    </div>

    <!-- Footer -->

    
<footer class="fixed-bottom">
  <div class="container mt-0">
    <a href="#top-anchor">↑</a>
    © Copyright 2025 William N. Havard.
    Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank">GitHub Pages</a>.

    <a href="https://william-n-havard.github.io/impressum">Impressum</a>.
    
    Last updated: January 06, 2025.
    <a href="#top-anchor">↑</a>
  </div>
</footer>



  </body>

  <!-- Bootsrap & MDB scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.4.4/umd/popper.min.js" integrity="sha512-eUQ9hGdLjBjY3F41CScH3UX+4JDSI9zXeroz7hJ+RteoCaY+GP/LDoM8AO+Pt+DRFw3nXqsjh9Zsts8hnYv8/A==" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha512-M5KW3ztuIICmVIhjSqXe01oV2bpe248gOxqmlcYrEzAvws7Pw3z6BK0iGbrwvdrUQUhi3eXgtxp5I8PDo9YfjQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js" integrity="sha512-Mug9KHKmroQFMLm93zGrjhibM2z2Obg9l6qFG2qKjXEXkMp/VDkI4uju9m4QKPjWSwQ6O2qzZEnJDEeCw0Blcw==" crossorigin="anonymous"></script>

  
<!-- Mansory & imagesLoaded -->
<script defer src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
<script defer src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
<script defer src="/assets/js/mansory.js" type="text/javascript"></script>


  

<script>
	// Source: https://www.w3schools.com/howto/howto_js_scroll_indicator.asp
	// When the user scrolls the page, execute myFunction 
	window.onscroll = function() {scrollFunction()};

	function scrollFunction() {
	  var winScroll = document.body.scrollTop || document.documentElement.scrollTop;
	  var height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
	  var scrolled = (winScroll / height) * 100;
	  document.getElementById("reading-progress-bar").style.width = scrolled + "%";
	}
</script>


<!-- Medium Zoom JS -->
<script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
<script src="/assets/js/zoom.js"></script>


<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>


</html>
